

===========================================
TOKENIZING LINE 1
open TouistTypes.Ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
      open TouistTypes.Ast
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 2
open TouistTypes

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-17): 
      open TouistTypes
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 3
open TouistPprint

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-18): 
      open TouistPprint
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 4
open TouistErr

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-15): 
      open TouistErr
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 5


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 6


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 7
(* Variables are stored in two data structures (global and local scopes). *)

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-24): 
       Variables are stored 
      * source.ts
    => TOKEN (24-26): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (26-47): 
       two data structures 
      * source.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (48-71): 
      global and local scopes
      * source.ts
    => TOKEN (71-72): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (72-74): 
      . 
      * source.ts
    => TOKEN (74-75): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (75-76): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 8


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 9
(* [env] is for local variables (for bigand,bigor and let constructs).

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-7): 
      env
      * source.ts
      * meta.array.literal.ts
    => TOKEN (7-8): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (8-9): 
       
      * source.ts
    => TOKEN (9-11): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-15): 
      for
      * source.ts
      * keyword.control.ts
    => TOKEN (15-32): 
       local variables 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-36): 
      for
      * source.ts
      * keyword.control.ts
    => TOKEN (36-53): 
       bigand,bigor and
      * source.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (54-57): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (58-68): 
      constructs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (68-70): 
      ).
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,2] BeginEndRule "null", entered @15
      * [33,3] BeginEndRule "null", entered @0
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 10
   It is a simple list [(name,description),...] passed as recursive argument.

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-6): 
         It 
      * source.ts
    => TOKEN (6-8): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (8-23): 
       a simple list 
      * source.ts
    => TOKEN (23-24): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (24-25): 
      (
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (25-41): 
      name,description
      * source.ts
      * meta.array.literal.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (42-46): 
      ,...
      * source.ts
      * meta.array.literal.ts
    => TOKEN (46-47): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (47-55): 
       passed 
      * source.ts
    => TOKEN (55-57): 
      as
      * source.ts
      * keyword.others.ts
    => TOKEN (57-78): 
       recursive argument.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,2] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 11
   The name is the variable name (e.g., '$var' or '$var(a,1,c)').

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-12): 
         The name 
      * source.ts
    => TOKEN (12-14): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (14-33): 
       the variable name 
      * source.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (34-40): 
      e.g., 
      * source.ts
    => TOKEN (40-41): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (41-45): 
      $var
      * source.ts
      * string.single.ts
    => TOKEN (45-46): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (46-50): 
       or 
      * source.ts
    => TOKEN (50-51): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (51-62): 
      $var(a,1,c)
      * source.ts
      * string.single.ts
    => TOKEN (62-63): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (63-64): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (64-66): 
      .
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,2] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 12
   The description is a couple (content, location) *)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-19): 
         The description 
      * source.ts
    => TOKEN (19-21): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (21-31): 
       a couple 
      * source.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (32-49): 
      content, location
      * source.ts
    => TOKEN (49-50): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (50-51): 
       
      * source.ts
    => TOKEN (51-52): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 13
type env = (string * (Ast.t * loc)) list

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-4): 
      type
      * source.ts
      * meta.type.declaration.ts
      * keyword.other.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (5-8): 
      env
      * source.ts
      * meta.type.declaration.ts
      * entity.name.class.ts
    => TOKEN (8-9): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (9-11): 
      = 
      * source.ts
      * meta.type.declaration.ts
      * keyword.operator.comparison.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (12-18): 
      string
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (18-20): 
       *
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (20-22): 
       (
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (22-27): 
      Ast.t
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (27-30): 
       * 
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (30-33): 
      loc
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (36-40): 
      list
      * source.ts
      * meta.type.declaration.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 14


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 15
(* [extenv] is for global variables (defined after 'data'). It is a hashtable

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-10): 
      extenv
      * source.ts
      * meta.array.literal.ts
    => TOKEN (10-11): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-14): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (14-15): 
       
      * source.ts
    => TOKEN (15-18): 
      for
      * source.ts
      * keyword.control.ts
    => TOKEN (18-36): 
       global variables 
      * source.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (37-51): 
      defined after 
      * source.ts
    => TOKEN (51-52): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (52-56): 
      data
      * source.ts
      * string.single.ts
    => TOKEN (56-57): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (57-58): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (58-63): 
      . It 
      * source.ts
    => TOKEN (63-65): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (65-78): 
       a hashtable
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,4] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 16
   accessible from anywhere where the elements are (name, description):

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
         accessible 
      * source.ts
    => TOKEN (14-18): 
      from
      * source.ts
      * keyword.control.import.include.ts
    => TOKEN (18-51): 
       anywhere where the elements are 
      * source.ts
    => TOKEN (51-52): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (52-69): 
      name, description
      * source.ts
    => TOKEN (69-70): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (70-72): 
      :
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,4] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 17
   The name is the variable name (e.g., '$var' or '$var(a,1,c)').

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-12): 
         The name 
      * source.ts
    => TOKEN (12-14): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (14-33): 
       the variable name 
      * source.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (34-40): 
      e.g., 
      * source.ts
    => TOKEN (40-41): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (41-45): 
      $var
      * source.ts
      * string.single.ts
    => TOKEN (45-46): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (46-50): 
       or 
      * source.ts
    => TOKEN (50-51): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (51-62): 
      $var(a,1,c)
      * source.ts
      * string.single.ts
    => TOKEN (62-63): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (63-64): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (64-66): 
      .
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,4] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 18
   The description is a couple (content, location) *)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-19): 
         The description 
      * source.ts
    => TOKEN (19-21): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (21-31): 
       a couple 
      * source.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (32-49): 
      content, location
      * source.ts
    => TOKEN (49-50): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (50-51): 
       
      * source.ts
    => TOKEN (51-52): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 19
type extenv = (string, (Ast.t * loc)) Hashtbl.t

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-4): 
      type
      * source.ts
      * meta.type.declaration.ts
      * keyword.other.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (5-11): 
      extenv
      * source.ts
      * meta.type.declaration.ts
      * entity.name.class.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (12-14): 
      = 
      * source.ts
      * meta.type.declaration.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (15-21): 
      string
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (22-24): 
       (
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (24-29): 
      Ast.t
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (29-32): 
       * 
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (32-35): 
      loc
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.paren.cover.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (38-47): 
      Hashtbl.t
      * source.ts
      * meta.type.declaration.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 20


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 21
let get_loc (ast:Ast.t) : loc option = match ast with

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-11): 
      get_loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (13-22): 
      ast:Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-23): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (24-25): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (26-29): 
      loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (30-36): 
      option
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (37-38): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (38-49): 
       match ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (49-53): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 22
    | Loc (_,loc) -> Some loc

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-10): 
       Loc 
      * source.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (11-16): 
      _,loc
      * source.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (17-18): 
       
      * source.ts
    => TOKEN (18-19): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (20-30): 
       Some loc
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 23
    | _ -> None

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-8): 
       _ 
      * source.ts
    => TOKEN (8-9): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (9-10): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (10-16): 
       None
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 24


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 25
let warning (ast:Ast.t) (message:string) =

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-11): 
      warning
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (13-22): 
      ast:Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-23): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (24-25): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (25-33): 
      message:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (33-39): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (41-42): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 26
  warn (Warning,Eval,message,get_loc ast)

  LINE CONTAINS 4 TOKENS:
    => TOKEN (0-7): 
        warn 
      * source.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (8-40): 
      Warning,Eval,message,get_loc ast
      * source.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 27


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 28
let ast_without_loc (ast:Ast.t) : Ast.t = match ast with

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-19): 
      ast_without_loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (21-30): 
      ast:Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (32-33): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (34-39): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (40-41): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (41-52): 
       match ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (52-56): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 29
  | Loc (ast,_) -> ast

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-8): 
       Loc 
      * source.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-14): 
      ast,_
      * source.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (15-16): 
       
      * source.ts
    => TOKEN (16-17): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (17-18): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (18-23): 
       ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 30
  | ast -> ast

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-8): 
       ast 
      * source.ts
    => TOKEN (8-9): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (9-10): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (10-15): 
       ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 31


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 32
(* [raise_with_loc] takes an ast that may contains a Loc (Loc is added in

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-18): 
      raise_with_loc
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-57): 
       takes an ast that may contains a Loc 
      * source.ts
    => TOKEN (57-58): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (58-62): 
      Loc 
      * source.ts
    => TOKEN (62-64): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (64-71): 
       added 
      * source.ts
    => TOKEN (71-73): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,5] BeginEndRule "null", entered @19
      * [33,6] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 33
   touistParser.mly) and raise an exception with the given message.

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-19): 
         touistParser.mly
      * source.ts
    => TOKEN (19-20): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (20-44): 
       and raise an exception 
      * source.ts
    => TOKEN (44-48): 
      with
      * source.ts
      * keyword.control.ts
    => TOKEN (48-68): 
       the given message.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,6] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 34
   The only purpose of giving 'ast' is to get the Loc thing.

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-20): 
         The only purpose 
      * source.ts
    => TOKEN (20-22): 
      of
      * source.ts
      * keyword.others.ts
    => TOKEN (22-30): 
       giving 
      * source.ts
    => TOKEN (30-31): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (31-34): 
      ast
      * source.ts
      * string.single.ts
    => TOKEN (34-35): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (35-36): 
       
      * source.ts
    => TOKEN (36-38): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (38-61): 
       to get the Loc thing.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,6] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 35
   [ast_without_loc] should not have been previously applied to [ast]

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-19): 
      ast_without_loc
      * source.ts
      * meta.array.literal.ts
    => TOKEN (19-20): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (20-64): 
       should not have been previously applied to 
      * source.ts
    => TOKEN (64-65): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (65-68): 
      ast
      * source.ts
      * meta.array.literal.ts
    => TOKEN (68-69): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,6] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 36
   because ast_without_loc will remove the Loc thing. *)

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-54): 
         because ast_without_loc will remove the Loc thing. 
      * source.ts
    => TOKEN (54-55): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 37
let raise_with_loc (ast:Ast.t) (message:string) = match ast with

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-18): 
      raise_with_loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (20-29): 
      ast:Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (32-40): 
      message:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (40-46): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (46-47): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (48-49): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (49-60): 
       match ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (60-64): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 38
  | Loc (ast,loc) -> fatal (Error,Eval,message,Some loc)

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-8): 
       Loc 
      * source.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-16): 
      ast,loc
      * source.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (17-18): 
       
      * source.ts
    => TOKEN (18-19): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (20-27): 
       fatal 
      * source.ts
    => TOKEN (27-28): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (28-55): 
      Error,Eval,message,Some loc
      * source.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 39
  | _ -> fatal (Error,Eval,message,None)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-6): 
       _ 
      * source.ts
    => TOKEN (6-7): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (8-15): 
       fatal 
      * source.ts
    => TOKEN (15-16): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (16-39): 
      Error,Eval,message,None
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 40


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 41
(* [raise_type_error] raises the errors that come from one-parameter functions.

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-20): 
      raise_type_error
      * source.ts
      * meta.array.literal.ts
    => TOKEN (20-21): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (21-50): 
       raises the errors that come 
      * source.ts
    => TOKEN (50-54): 
      from
      * source.ts
      * keyword.control.import.include.ts
    => TOKEN (54-58): 
       one
      * source.ts
    => TOKEN (58-59): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (59-80): 
      parameter functions.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 42
   operator is the non-expanded (expand = eval_ast) operator.

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-12): 
         operator 
      * source.ts
    => TOKEN (12-14): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (14-22): 
       the non
      * source.ts
    => TOKEN (22-23): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (23-32): 
      expanded 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-40): 
      expand 
      * source.ts
    => TOKEN (40-41): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (41-50): 
       eval_ast
      * source.ts
    => TOKEN (50-51): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (51-62): 
       operator.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 43
   Example: in 'To_int x', 'operand' is the non-expanded parameter 'x',

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-12): 
         Example: 
      * source.ts
    => TOKEN (12-14): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (14-15): 
       
      * source.ts
    => TOKEN (15-16): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (16-24): 
      To_int x
      * source.ts
      * string.single.ts
    => TOKEN (24-25): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (25-27): 
      , 
      * source.ts
    => TOKEN (27-28): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (28-35): 
      operand
      * source.ts
      * string.single.ts
    => TOKEN (35-36): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (36-37): 
       
      * source.ts
    => TOKEN (37-39): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (39-47): 
       the non
      * source.ts
    => TOKEN (47-48): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (48-67): 
      expanded parameter 
      * source.ts
    => TOKEN (67-68): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (68-69): 
      x
      * source.ts
      * string.single.ts
    => TOKEN (69-70): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (70-72): 
      ,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 44
   'expanded' is the expanded parameter 'x'.

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
    => TOKEN (3-4): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (4-12): 
      expanded
      * source.ts
      * string.single.ts
    => TOKEN (12-13): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-16): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (16-40): 
       the expanded parameter 
      * source.ts
    => TOKEN (40-41): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (41-42): 
      x
      * source.ts
      * string.single.ts
    => TOKEN (42-43): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (43-45): 
      .
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 45
   Expanded means that eval_ast has been applied to x.

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-55): 
         Expanded means that eval_ast has been applied to x.
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 46
   [expected_types] contain a string that explain what is expected, e.g.,

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-18): 
      expected_types
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-30): 
       contain a 
      * source.ts
    => TOKEN (30-36): 
      string
      * source.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (36-55): 
       that explain what 
      * source.ts
    => TOKEN (55-57): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (57-74): 
       expected, e.g.,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,7] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 47
   'an integer or a float'. *)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
    => TOKEN (3-4): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (4-25): 
      an integer or a float
      * source.ts
      * string.single.ts
    => TOKEN (25-26): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (26-28): 
      . 
      * source.ts
    => TOKEN (28-29): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 48
let raise_type_error operator operand expanded (expected_types:string) =

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-20): 
      raise_type_error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (21-47): 
      operator operand expanded 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (48-63): 
      expected_types:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (63-69): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (69-70): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (70-71): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (71-72): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 49
  raise_with_loc operator (

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-26): 
        raise_with_loc operator 
      * source.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,8] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 50
    "'"^(string_of_ast_type operator)^"' expects "^expected_types^". "^

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-6): 
      '
      * source.ts
      * string.double.ts
    => TOKEN (6-7): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (7-8): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-36): 
      string_of_ast_type operator
      * source.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (37-38): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (38-39): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (39-49): 
      ' expects 
      * source.ts
      * string.double.ts
    => TOKEN (49-50): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (50-51): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (51-65): 
      expected_types
      * source.ts
    => TOKEN (65-66): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (66-67): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (67-69): 
      . 
      * source.ts
      * string.double.ts
    => TOKEN (69-70): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (70-71): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,8] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 51
    "The operand:\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-17): 
      The operand:
      * source.ts
      * string.double.ts
    => TOKEN (17-19): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (19-20): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (20-21): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,8] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 52
    "    "^(string_of_ast operand)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-33): 
      string_of_ast operand
      * source.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (34-35): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (35-36): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (36-38): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (38-39): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (39-40): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,8] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 53
    "has been expanded to something of type '"^(string_of_ast_type expanded)^"':\n"^

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-45): 
      has been expanded to something of type '
      * source.ts
      * string.double.ts
    => TOKEN (45-46): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (46-47): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (48-75): 
      string_of_ast_type expanded
      * source.ts
    => TOKEN (75-76): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (76-77): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (77-78): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (78-80): 
      ':
      * source.ts
      * string.double.ts
    => TOKEN (80-82): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (82-83): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (83-84): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,8] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 54
    "    "^(string_of_ast expanded)^"\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-34): 
      string_of_ast expanded
      * source.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (35-36): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (36-37): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (37-39): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (39-40): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 55


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 56
(* Same as above but for functions of two parameters. Example: with And (x,y),

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-8): 
       Same 
      * source.ts
    => TOKEN (8-10): 
      as
      * source.ts
      * keyword.others.ts
    => TOKEN (10-21): 
       above but 
      * source.ts
    => TOKEN (21-24): 
      for
      * source.ts
      * keyword.control.ts
    => TOKEN (24-35): 
       functions 
      * source.ts
    => TOKEN (35-37): 
      of
      * source.ts
      * keyword.others.ts
    => TOKEN (37-63): 
       two parameters. Example: 
      * source.ts
    => TOKEN (63-67): 
      with
      * source.ts
      * keyword.control.ts
    => TOKEN (67-72): 
       And 
      * source.ts
    => TOKEN (72-73): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (73-76): 
      x,y
      * source.ts
    => TOKEN (76-77): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (77-79): 
      ,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,9] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 57
   operator is And (x,y),

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-12): 
         operator 
      * source.ts
    => TOKEN (12-14): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (14-19): 
       And 
      * source.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (20-23): 
      x,y
      * source.ts
    => TOKEN (23-24): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (24-26): 
      ,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,9] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 58
   op1 and op2 are the non-expanded parameters x and y,

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-26): 
         op1 and op2 are the non
      * source.ts
    => TOKEN (26-27): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (27-56): 
      expanded parameters x and y,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,9] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 59
   exp1 and exp2 are the expanded parameters x and y. *)

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-54): 
         exp1 and exp2 are the expanded parameters x and y. 
      * source.ts
    => TOKEN (54-55): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 60
let raise_type_error2 operator op1 exp1 op2 exp2 (expected_types:string) =

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-21): 
      raise_type_error2
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-49): 
      operator op1 exp1 op2 exp2 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (49-50): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (50-65): 
      expected_types:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (65-71): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (71-72): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (73-74): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 61
  raise_with_loc operator

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-26): 
        raise_with_loc operator
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 62
    ("incorrect types with '"^(string_of_ast_type operator)^"'; expects "^expected_types^". "^

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (5-6): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (6-28): 
      incorrect types with '
      * source.ts
      * string.double.ts
    => TOKEN (28-29): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (29-30): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (31-58): 
      string_of_ast_type operator
      * source.ts
    => TOKEN (58-59): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (59-60): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (60-61): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (61-72): 
      '; expects 
      * source.ts
      * string.double.ts
    => TOKEN (72-73): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (73-74): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (74-88): 
      expected_types
      * source.ts
    => TOKEN (88-89): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (89-90): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (90-92): 
      . 
      * source.ts
      * string.double.ts
    => TOKEN (92-93): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (93-94): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 63
    "In statement:\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-18): 
      In statement:
      * source.ts
      * string.double.ts
    => TOKEN (18-20): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (20-21): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (21-22): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 64
    "    "^(string_of_ast operator)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-34): 
      string_of_ast operator
      * source.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (35-36): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (36-37): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (37-39): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (39-40): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (40-41): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 65
    "Left-hand operand has type '"^(string_of_ast_type exp1)^"':\n"^

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-33): 
      Left-hand operand has type '
      * source.ts
      * string.double.ts
    => TOKEN (33-34): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (34-35): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (36-59): 
      string_of_ast_type exp1
      * source.ts
    => TOKEN (59-60): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (60-61): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (61-62): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (62-64): 
      ':
      * source.ts
      * string.double.ts
    => TOKEN (64-66): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (66-67): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (67-68): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 66
    "    "^(string_of_ast exp1)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-30): 
      string_of_ast exp1
      * source.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (33-35): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (35-36): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (36-37): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 67
    "Right-hand operand has type '"^(string_of_ast_type exp2)^"':\n"^

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-34): 
      Right-hand operand has type '
      * source.ts
      * string.double.ts
    => TOKEN (34-35): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (35-36): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (37-60): 
      string_of_ast_type exp2
      * source.ts
    => TOKEN (60-61): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (61-62): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (62-63): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (63-65): 
      ':
      * source.ts
      * string.double.ts
    => TOKEN (65-67): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (67-68): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (68-69): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,10] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 68
    "    "^(string_of_ast exp2)^"\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-30): 
      string_of_ast exp2
      * source.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (33-35): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (35-36): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 69


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 70
(* [raise_set_decl] is the same as [raise_type_error2] but between one element

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-18): 
      raise_set_decl
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-20): 
       
      * source.ts
    => TOKEN (20-22): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (22-32): 
       the same 
      * source.ts
    => TOKEN (32-34): 
      as
      * source.ts
      * keyword.others.ts
    => TOKEN (34-35): 
       
      * source.ts
    => TOKEN (35-36): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (36-53): 
      raise_type_error2
      * source.ts
      * meta.array.literal.ts
    => TOKEN (53-54): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (54-79): 
       but between one element
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,11] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 71
   and the set this element is supposed to be added to. *)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-15): 
         and the set 
      * source.ts
    => TOKEN (15-19): 
      this
      * source.ts
      * constant.language.this.ts
    => TOKEN (19-28): 
       element 
      * source.ts
    => TOKEN (28-30): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (30-56): 
       supposed to be added to. 
      * source.ts
    => TOKEN (56-57): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (57-58): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 72
let raise_set_decl ast elmt elmt_expanded set set_expanded (expected_types:string) =

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-18): 
      raise_set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (19-59): 
      ast elmt elmt_expanded set set_expanded 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (59-60): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (60-75): 
      expected_types:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (75-81): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (81-82): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (82-83): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (83-84): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 73
  raise_with_loc ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        raise_with_loc ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 74
    ("Ill-formed set declaration. It expects "^expected_types^". "^

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (5-6): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (6-45): 
      Ill-formed set declaration. It expects 
      * source.ts
      * string.double.ts
    => TOKEN (45-46): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (46-47): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (47-61): 
      expected_types
      * source.ts
    => TOKEN (61-62): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (62-63): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (63-65): 
      . 
      * source.ts
      * string.double.ts
    => TOKEN (65-66): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (66-67): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 75
    "One of the elements is of type '"^(string_of_ast_type elmt_expanded)^"':\n"^

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-37): 
      One of the elements is of type '
      * source.ts
      * string.double.ts
    => TOKEN (37-38): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (38-39): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (39-40): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-72): 
      string_of_ast_type elmt_expanded
      * source.ts
    => TOKEN (72-73): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (73-74): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (74-75): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (75-77): 
      ':
      * source.ts
      * string.double.ts
    => TOKEN (77-79): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (79-80): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (80-81): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 76
    "    "^(string_of_ast elmt)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-30): 
      string_of_ast elmt
      * source.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (33-35): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (35-36): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (36-37): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 77
    "This element has been expanded to\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-38): 
      This element has been expanded to
      * source.ts
      * string.double.ts
    => TOKEN (38-40): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (40-41): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (41-42): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 78
    "    "^(string_of_ast elmt_expanded)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-39): 
      string_of_ast elmt_expanded
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-41): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (41-42): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (42-44): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (44-45): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (45-46): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 79
    "Up to now, the set declaration\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-35): 
      Up to now, the set declaration
      * source.ts
      * string.double.ts
    => TOKEN (35-37): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (37-38): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (38-39): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 80
    "    "^(string_of_ast set)^"\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-29): 
      string_of_ast set
      * source.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (30-31): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (31-32): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (32-34): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (34-35): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (35-36): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 81
    "has been expanded to:\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-26): 
      has been expanded to:
      * source.ts
      * string.double.ts
    => TOKEN (26-28): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (28-29): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (29-30): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,12] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 82
    "    "^(string_of_ast set_expanded)^"\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-38): 
      string_of_ast set_expanded
      * source.ts
    => TOKEN (38-39): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (39-40): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (40-41): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (41-43): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (43-44): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 83


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 84


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 85
let check_nb_vars_same_as_nb_sets (ast:Ast.t) (vars:Ast.t list) (sets:Ast.t list) : unit =

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-33): 
      check_nb_vars_same_as_nb_sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (35-44): 
      ast:Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (46-47): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (47-62): 
      vars:Ast.t list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (62-63): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (64-65): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (65-80): 
      sets:Ast.t list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (80-81): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (81-82): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (82-83): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (83-84): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (84-88): 
      unit
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (88-89): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (89-90): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 86
  let loc = match (List.nth vars 0), List.nth sets ((List.length sets)-1) with

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (6-9): 
      loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (9-11): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (11-18): 
       match 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (19-33): 
      List.nth vars 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (33-34): 
      0
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.numeric.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (35-37): 
      , 
      * source.ts
      * meta.var.expr.ts
    => TOKEN (37-41): 
      List
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (41-51): 
      .nth sets 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (51-52): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (52-53): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (53-69): 
      List.length sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (69-70): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (70-71): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (71-72): 
      1
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.numeric.ts
    => TOKEN (72-73): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (74-78): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 87
    | Loc (_,(startpos,_)), Loc (_,(_,endpos)) -> startpos,endpos

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-10): 
       Loc 
      * source.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (11-13): 
      _,
      * source.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-24): 
      startpos,_
      * source.ts
    => TOKEN (24-25): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (26-32): 
      , Loc 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-35): 
      _,
      * source.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (36-44): 
      _,endpos
      * source.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (46-47): 
       
      * source.ts
    => TOKEN (47-48): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (48-49): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (49-66): 
       startpos,endpos
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 88
    | _-> failwith "[shouldn't happen] missing locations in vars/sets"

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-7): 
       _
      * source.ts
    => TOKEN (7-8): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (8-9): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (9-19): 
       failwith 
      * source.ts
    => TOKEN (19-20): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (20-69): 
      [shouldn't happen] missing locations in vars/sets
      * source.ts
      * string.double.ts
    => TOKEN (69-70): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 89
  in

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-4): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 90
  match (List.length vars) = (List.length sets) with

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-8): 
        match 
      * source.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-25): 
      List.length vars
      * source.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (26-27): 
       
      * source.ts
    => TOKEN (27-28): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (28-29): 
       
      * source.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (30-46): 
      List.length sets
      * source.ts
    => TOKEN (46-47): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (47-48): 
       
      * source.ts
    => TOKEN (48-52): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 91
  | true -> ()

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-4): 
       
      * source.ts
    => TOKEN (4-8): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (8-9): 
       
      * source.ts
    => TOKEN (9-10): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (10-11): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 92
  | false -> fatal (Error,Eval,

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-4): 
       
      * source.ts
    => TOKEN (4-9): 
      false
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (9-10): 
       
      * source.ts
    => TOKEN (10-11): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (12-19): 
       fatal 
      * source.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (20-32): 
      Error,Eval,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @12
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 93
    "Ill-formed '"^(string_of_ast_type ast)^"'. The number of variables and sets must be the same. "^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-17): 
      Ill-formed '
      * source.ts
      * string.double.ts
    => TOKEN (17-18): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (18-19): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (20-42): 
      string_of_ast_type ast
      * source.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (43-44): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (44-45): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (45-99): 
      '. The number of variables and sets must be the same. 
      * source.ts
      * string.double.ts
    => TOKEN (99-100): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (100-101): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 94
    "You defined "^(string_of_int (List.length vars))^" variables:\n"^

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-17): 
      You defined 
      * source.ts
      * string.double.ts
    => TOKEN (17-18): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (18-19): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (20-34): 
      string_of_int 
      * source.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (35-51): 
      List.length vars
      * source.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (53-54): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (54-55): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (55-66): 
       variables:
      * source.ts
      * string.double.ts
    => TOKEN (66-68): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (68-69): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (69-70): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 95
    "    "^(string_of_ast_list "," vars)^"\n"^

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-31): 
      string_of_ast_list 
      * source.ts
    => TOKEN (31-32): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * string.double.ts
    => TOKEN (33-34): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (34-39): 
       vars
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-41): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (41-42): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (42-44): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (44-45): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (45-46): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 96
    "but you gave "^(string_of_int (List.length sets))^" sets:\n"^

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-18): 
      but you gave 
      * source.ts
      * string.double.ts
    => TOKEN (18-19): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (19-20): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (21-35): 
      string_of_int 
      * source.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (36-52): 
      List.length sets
      * source.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (53-54): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (54-55): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (55-56): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (56-62): 
       sets:
      * source.ts
      * string.double.ts
    => TOKEN (62-64): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (64-65): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (65-66): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 97
    "    "^(string_of_ast_list "," sets)^"\n"

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (5-9): 
          
      * source.ts
      * string.double.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-31): 
      string_of_ast_list 
      * source.ts
    => TOKEN (31-32): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * string.double.ts
    => TOKEN (33-34): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (34-39): 
       sets
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-41): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (41-42): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (42-44): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (44-45): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,13] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 98
    ,Some loc)

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-13): 
          ,Some loc
      * source.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 99


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 100
let extenv = ref (Hashtbl.create 0)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-10): 
      extenv
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (10-12): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (12-17): 
       ref 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (18-33): 
      Hashtbl.create 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (33-34): 
      0
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.numeric.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 101
let check_only = ref false

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-14): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (14-16): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (16-21): 
       ref 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (21-26): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 102


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 103
(* [check_only] allows to only 'check the types'. It prevents the bigand,

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-3): 
       
      * source.ts
    => TOKEN (3-4): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (4-14): 
      check_only
      * source.ts
      * meta.array.literal.ts
    => TOKEN (14-15): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (15-31): 
       allows to only 
      * source.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (32-47): 
      check the types
      * source.ts
      * string.single.ts
    => TOKEN (47-48): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (48-74): 
      . It prevents the bigand,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,14] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 104
    bigor, exact, atmost, atleast and range to expand completely(as it

  LINE CONTAINS 4 TOKENS:
    => TOKEN (0-64): 
          bigor, exact, atmost, atleast and range to expand completely
      * source.ts
    => TOKEN (64-65): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (65-67): 
      as
      * source.ts
      * keyword.others.ts
    => TOKEN (67-71): 
       it
      * source.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,15] BeginEndRule "null", entered @0
      * [33,14] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 105
    may take a lot of time to do so). *)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-19): 
          may take a lot 
      * source.ts
    => TOKEN (19-21): 
      of
      * source.ts
      * keyword.others.ts
    => TOKEN (21-30): 
       time to 
      * source.ts
    => TOKEN (30-32): 
      do
      * source.ts
      * keyword.control.ts
    => TOKEN (32-35): 
       so
      * source.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (36-38): 
      . 
      * source.ts
    => TOKEN (38-39): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 106
let check_only = ref false

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-14): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (14-16): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (16-21): 
       ref 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (21-26): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 107


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 108
(* By default, we are in 'SAT' mode. When [smt] is true,

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (1-2): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (2-6): 
       By 
      * source.ts
    => TOKEN (6-13): 
      default
      * source.ts
      * keyword.control.ts
    => TOKEN (13-22): 
      , we are 
      * source.ts
    => TOKEN (22-24): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (24-25): 
       
      * source.ts
    => TOKEN (25-26): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (26-29): 
      SAT
      * source.ts
      * string.single.ts
    => TOKEN (29-30): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (30-42): 
       mode. When 
      * source.ts
    => TOKEN (42-43): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (43-46): 
      smt
      * source.ts
      * meta.array.literal.ts
    => TOKEN (46-47): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (47-48): 
       
      * source.ts
    => TOKEN (48-50): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (50-51): 
       
      * source.ts
    => TOKEN (51-55): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (55-57): 
      ,
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,16] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 109
   some type checking (variable expansion mostly) is different

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-8): 
         some 
      * source.ts
    => TOKEN (8-12): 
      type
      * source.ts
      * meta.type.declaration.ts
      * keyword.other.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (13-21): 
      checking
      * source.ts
      * meta.type.declaration.ts
      * entity.name.class.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (23-31): 
      variable
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (32-41): 
      expansion
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (42-48): 
      mostly
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.type.declaration.ts
      * meta.type.paren.cover.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (50-52): 
      is
      * source.ts
      * meta.type.declaration.ts
      * meta.type.name.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.type.declaration.ts
    => TOKEN (53-62): 
      different
      * source.ts
      * meta.type.declaration.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,16] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 110
   (formulas can be 'int' or 'float' for example). *)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
    => TOKEN (3-4): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (4-20): 
      formulas can be 
      * source.ts
    => TOKEN (20-21): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (21-24): 
      int
      * source.ts
      * string.single.ts
    => TOKEN (24-25): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (25-29): 
       or 
      * source.ts
    => TOKEN (29-30): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (30-35): 
      float
      * source.ts
      * string.single.ts
    => TOKEN (35-36): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (36-37): 
       
      * source.ts
    => TOKEN (37-40): 
      for
      * source.ts
      * keyword.control.ts
    => TOKEN (40-48): 
       example
      * source.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (49-51): 
      . 
      * source.ts
    => TOKEN (51-52): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 111
let smt = ref false

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      smt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (7-9): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (9-14): 
       ref 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (14-19): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 112


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 113
let rec eval ?smt:(smt_mode=false) ?(onlychecktypes=false) ast : Ast.t =

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-3): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (8-13): 
      eval 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (13-14): 
      ?
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (14-17): 
      smt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (17-18): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (19-27): 
      smt_mode
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-28): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (28-33): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (35-36): 
      ?
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (37-51): 
      onlychecktypes
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (51-52): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (52-57): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts
    => TOKEN (57-58): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (58-63): 
       ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (63-64): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (64-71): 
       Ast.t 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (71-72): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 114
  check_only := onlychecktypes;

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-14): 
        check_only :
      * source.ts
    => TOKEN (14-15): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (15-32): 
       onlychecktypes;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 115
  smt := smt_mode;

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-7): 
        smt :
      * source.ts
    => TOKEN (7-8): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (8-19): 
       smt_mode;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 116
  extenv := Hashtbl.create 50; (* extenv must be re-init between two calls to [eval] *)

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-10): 
        extenv :
      * source.ts
    => TOKEN (10-11): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (11-27): 
       Hashtbl.create 
      * source.ts
    => TOKEN (27-29): 
      50
      * source.ts
      * constant.numeric.ts
    => TOKEN (29-31): 
      ; 
      * source.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (32-33): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (33-51): 
       extenv must be re
      * source.ts
    => TOKEN (51-52): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (52-78): 
      init between two calls to 
      * source.ts
    => TOKEN (78-79): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (79-83): 
      eval
      * source.ts
      * meta.array.literal.ts
    => TOKEN (83-84): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (84-85): 
       
      * source.ts
    => TOKEN (85-86): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 117
  eval_touist_code [] ast

  LINE CONTAINS 4 TOKENS:
    => TOKEN (0-19): 
        eval_touist_code 
      * source.ts
    => TOKEN (19-20): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (20-21): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (21-26): 
       ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 118


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 119
and eval_touist_code (env:env) ast :Ast.t =

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-21): 
      and eval_touist_code 
      * source.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (22-29): 
      env:env
      * source.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (30-42): 
       ast :Ast.t 
      * source.ts
    => TOKEN (42-43): 
      =
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 120


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 121
  let rec affect_vars = function

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (6-9): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (10-22): 
      affect_vars 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-23): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (24-32): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * storage.type.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,17] BeginEndRule "meta.function.ts", entered @23
      * [38,18] BeginEndRule "meta.var-single-variable.expr.ts", entered @5
      * [36,19] BeginEndRule "meta.var.expr.ts", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 122
    | [] -> []

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-15): 
          | [] -> []
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,17] BeginEndRule "meta.function.ts", entered @-1
      * [38,18] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,19] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 123
    | Loc (Affect (Loc (Var (p,i),var_loc),y),affect_loc)::xs ->

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-10): 
          | Loc 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-17): 
      Affect
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-22): 
      Loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-27): 
      Var
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-57): 
      ,var_loc),y),affect_loc)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (57-58): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (58-59): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (59-61): 
      xs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (61-64): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,17] BeginEndRule "meta.function.ts", entered @-1
      * [38,18] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,19] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 124
      Hashtbl.replace !extenv (expand_var_name env (p,i)) (eval_ast env y, var_loc);

  LINE CONTAINS 23 TOKENS:
    => TOKEN (0-30): 
            Hashtbl.replace !extenv 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-46): 
      expand_var_name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-50): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-52): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (52-53): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-55): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (56-58): 
      ) 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (58-59): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (59-67): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-71): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-73): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (74-75): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (75-82): 
      var_loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (82-83): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (83-85): 
      ;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 125
        affect_vars xs

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
              affect_vars xs
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 126
    | x::xs -> x::(affect_vars xs)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-12): 
       x::xs 
      * source.ts
    => TOKEN (12-13): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-18): 
       x::
      * source.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (19-33): 
      affect_vars xs
      * source.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 127
  in

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-4): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 128
  let rec process_formulas = function

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (6-9): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (10-27): 
      process_formulas 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-28): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (29-37): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * storage.type.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @28
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @5
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 129
    | []    -> raise_with_loc ast ("no formulas")

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-34): 
          | []    -> raise_with_loc ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-38): 
      no
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-47): 
      formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 130
    | x::[] -> x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-17): 
          | x::[] -> x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 131
    | x::xs -> And (x, process_formulas xs)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-19): 
          | x::xs -> And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-21): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-39): 
      process_formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-42): 
      xs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 132
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 133
  match ast_without_loc ast with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
        match ast_without_loc ast with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 134
  | Touist_code (formulas) ->

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-16): 
        | Touist_code 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-25): 
      formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-30): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 135
    eval_ast_formula env (process_formulas (affect_vars formulas))

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-25): 
          eval_ast_formula env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-42): 
      process_formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (44-55): 
      affect_vars
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-64): 
      formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (65-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 136
  | e -> raise_with_loc ast ("this does not seem to be a touist code structure: " ^ string_of_ast e ^"\n")

  LINE CONTAINS 31 TOKENS:
    => TOKEN (0-28): 
        | e -> raise_with_loc ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-30): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-34): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-39): 
      does
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-43): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      seem
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-51): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-54): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-56): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-63): 
      touist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-68): 
      code
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-78): 
      structure
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (78-79): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (79-80): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (80-81): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (81-101): 
       ^ string_of_ast e ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (101-102): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (102-103): 
      \
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (103-104): 
      n
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (104-105): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (105-106): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,23] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 137


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,23] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 138
(* [eval_ast] evaluates (= expands) numerical, boolean and set expresions that

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-4): 
      (* [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-12): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-23): 
      evaluates
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-25): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (26-34): 
       expands
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-79): 
       numerical, boolean and set expresions that
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 139
   are not directly in formulas. For example, in 'when $a!=a' or 'if 3>4',

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-75): 
         are not directly in formulas. For example, in 'when $a!=a' or 'if 3>4',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 140
   the boolean values must be computed: eval_ast will do exactly that.*)

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-73): 
         the boolean values must be computed: eval_ast will do exactly that.*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 141
and eval_ast (env:env) (ast:Ast.t) : Ast.t =

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-13): 
      and eval_ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-17): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (18-21): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-27): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (28-33): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-36): 
       :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (37-42): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (42-44): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 142
  let eval_ast = eval_ast env in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
        let eval_ast = eval_ast env in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 143
  let expanded = match ast_without_loc ast with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-48): 
        let expanded = match ast_without_loc ast with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 144
  | Int x   -> Int x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Int x   -> Int x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 145
  | Float x -> Float x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
        | Float x -> Float x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 146
  | Bool x  -> Bool x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-22): 
        | Bool x  -> Bool x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 147
  | Var (p,i) -> (* p,i = prefix, indices *)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-8): 
        | Var 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-19): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-25): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (25-32): 
       prefix
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-41): 
      indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-43): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 148
    let name = expand_var_name env (p,i) in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-35): 
          let name = expand_var_name env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (36-37): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-39): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (40-44): 
       in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 149
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 150
      try let (content,loc) = List.assoc name env in content

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
            try let 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-22): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-26): 
      loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-61): 
       = List.assoc name env in content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 151
      with Not_found ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-24): 
            with Not_found ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 152
      try let (content,_) = Hashtbl.find !extenv name in content

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
            try let 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-22): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (25-65): 
       = Hashtbl.find !extenv name in content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 153
      with Not_found -> raise_with_loc ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-43): 
            with Not_found -> raise_with_loc ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 154
          ("variable '" ^ name ^"' does not seem to be known. Either you forgot "^

  LINE CONTAINS 31 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-20): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-25): 
      '" ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-30): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-34): 
      ^"'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-39): 
      does
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-43): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      seem
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-51): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-54): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-60): 
      known
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-68): 
      Either
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-72): 
      you
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (73-79): 
      forgot
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (80-83): 
      "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,24] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 155
          "to declare it globally or it has been previously declared locally "^

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-11): 
                "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-13): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-21): 
      declare
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      it
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-33): 
      globally
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-36): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      it
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-43): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-59): 
      previously
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-68): 
      declared
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-76): 
      locally
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-80): 
      "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,24] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 156
          "(with bigand, bigor or let) and you are out of its scope."^"\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-12): 
                "(
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-16): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-23): 
      bigand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-30): 
      bigor
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-33): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-37): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (38-76): 
       and you are out of its scope."^"\n")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 157
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 158
  | Set x -> Set x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-19): 
        | Set x -> Set x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 159
  | Set_decl x -> eval_set_decl env ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
        | Set_decl x -> eval_set_decl env ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 160
  | Neg x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-13): 
        | Neg x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-19): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-28): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-35): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,25] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 161
      | Int x'   -> Int   (- x')

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-19): 
      '   ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-23): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-26): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-28): 
      (-
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 162
      | Float x' -> Float (-. x')

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-26): 
            | Float x' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-29): 
      -.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 163
      | x' -> raise_type_error ast x x' "'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-60): 
            | x' -> raise_type_error ast x x' "'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 164
  | Add (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Add 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,26] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 165
      | Int x, Int y -> Int (x + y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      +
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 166
      | Float x, Float y -> Float (x +. y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-34): 
            | Float x, Float y -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      +.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 167
      | x',y' -> raise_type_error2 ast x x' y y' "'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-69): 
            | x',y' -> raise_type_error2 ast x x' y y' "'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 168
  | Sub (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Sub 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,27] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 169
      | Int x, Int y -> Int (x - y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 170
      | Float x, Float y -> Float (x -. y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-34): 
            | Float x, Float y -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      -.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 171
      | x',y' -> raise_type_error2 ast x x' y y' "'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-69): 
            | x',y' -> raise_type_error2 ast x x' y y' "'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 172
  | Mul (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Mul 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,28] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 173
      | Int x, Int y -> Int (x * y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 174
      | Float x, Float y -> Float (x *. y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-34): 
            | Float x, Float y -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      *.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 175
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 176
  | Div (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Div 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,29] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 177
      | Int x, Int y -> Int (x / y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      /
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 178
      | Float x, Float y -> Float (x /. y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-34): 
            | Float x, Float y -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      /.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 179
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 180
  | Mod (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Mod 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,30] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 181
      | Int x, Int y -> Int (x mod y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-34): 
      mod
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 182
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 183
  | Sqrt x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-14): 
        | Sqrt x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-20): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-29): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-36): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,31] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 184
      | Float x -> Float (sqrt x)

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-13): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-15): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-24): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-30): 
      sqrt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 185
      | x' -> raise_type_error ast x x' "a float")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-51): 
            | x' -> raise_type_error ast x x' "a float")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 186
  | To_int x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-16): 
        | To_int x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-22): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-31): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-38): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,32] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 187
      | Float x -> Int (int_of_float x)

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-13): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-15): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-22): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-36): 
      int_of_float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 188
      | Int x   -> Int x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-25): 
            | Int x   -> Int x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 189
      | x' -> raise_type_error ast x x' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-62): 
            | x' -> raise_type_error ast x x' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 190
  | To_float x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-18): 
        | To_float x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-24): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-33): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-40): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,33] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 191
      | Int x   -> Float (float_of_int x)

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-16): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-24): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-38): 
      float_of_int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-40): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 192
      | Float x -> Float x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
            | Float x -> Float x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 193
      | x' -> raise_type_error ast x x' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-62): 
            | x' -> raise_type_error ast x x' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 194
  | Abs x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-13): 
        | Abs x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-19): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-28): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-35): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,34] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 195
      | Int x   -> Int (abs x)

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-16): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-22): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-27): 
      abs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 196
      | Float x -> Float (abs_float x)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-25): 
            | Float x -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-35): 
      abs_float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 197
      | x' -> raise_type_error ast x x' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-62): 
            | x' -> raise_type_error ast x x' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 198
  | Not x -> (match eval_ast x with

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-13): 
        | Not x -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-19): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-28): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-35): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,35] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 199
      | Bool x -> Bool (not x)

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-17): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-22): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-27): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 200
      | x' -> raise_type_error ast x x' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-52): 
            | x' -> raise_type_error ast x x' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 201
  | And (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,36] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 202
      | Bool x,Bool y -> Bool (x && y)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-19): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      &&
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 203
      | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 204
  | Or (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-7): 
        | Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-9): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-16): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-22): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-31): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-43): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-45): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-50): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,37] BeginEndRule "meta.function.type.parameter.ts", entered @12
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 205
      | Bool x,Bool y -> Bool (x || y)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-19): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      ||
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 206
      | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 207
  | Xor (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-8): 
        | Xor 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-23): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-34): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,38] BeginEndRule "meta.function.type.parameter.ts", entered @13
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 208
      | Bool x,Bool y -> Bool ((x || y) && (not (x && y)))

  LINE CONTAINS 33 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-19): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-32): 
      ((
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-36): 
      ||
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-38): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (39-43): 
       && 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-47): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-53): 
      &&
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-55): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (56-59): 
      ))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 209
      | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 210
  | Implies (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-21): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-27): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-36): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-48): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-50): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-55): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,39] BeginEndRule "meta.function.type.parameter.ts", entered @17
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 211
      | Bool x,Bool y -> Bool (not x || y)

  LINE CONTAINS 23 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-19): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-34): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-39): 
      ||
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 212
      | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 213
  | Equiv (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-10): 
        | Equiv 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-19): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-25): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-34): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-46): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-48): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-53): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,40] BeginEndRule "meta.function.type.parameter.ts", entered @15
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 214
      | Bool x,Bool y -> Bool ((not x || y) && (not x || y))

  LINE CONTAINS 34 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-12): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-19): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-24): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-32): 
      ((
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-35): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-40): 
      ||
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-42): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (43-47): 
       && 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-51): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-53): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-56): 
      ||
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-58): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (59-61): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 215
      | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'bool'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 216
  | If (x,y,z) ->

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-7): 
        | If 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-9): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      z
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-18): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 217
    let test =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-15): 
          let test =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 218
      match eval_ast x with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-28): 
            match eval_ast x with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 219
      | Bool true  -> true

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
            | Bool true  -> true
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 220
      | Bool false -> false

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-28): 
            | Bool false -> false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 221
      | x' -> raise_type_error ast x x' "a 'bool'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-51): 
            | x' -> raise_type_error ast x x' "a 'bool'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 222
    in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-7): 
          in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 223
    if test then eval_ast y else eval_ast z

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-44): 
          if test then eval_ast y else eval_ast z
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 224
  | Union (x,y) -> begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
        | Union 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-25): 
       -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 225
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 226
      | Set a, Set b -> Set (AstSet.union a b)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-28): 
            | Set a, Set b -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-35): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-41): 
      union
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-43): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-45): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 227
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-90): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 228
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 229
  | Inter (x,y) -> begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
        | Inter 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-25): 
       -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 230
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 231
      | Set a, Set b -> Set (AstSet.inter a b)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-28): 
            | Set a, Set b -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-35): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-41): 
      inter
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-43): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-45): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 232
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-90): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 233
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 234
  | Diff (x,y) -> begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-9): 
        | Diff 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (9-10): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (10-11): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-24): 
       -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 235
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 236
      | Set a, Set b -> Set (AstSet.diff a b)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-28): 
            | Set a, Set b -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-35): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-40): 
      diff
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-42): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 237
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-90): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', 'int-set' or 'prop-set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 238
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 239
  | Range (x,y) -> (* !check_only will simplify [min..max] to [min..min] *)

  LINE CONTAINS 29 TOKENS:
    => TOKEN (0-10): 
        | Range 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-19): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-23): 
      * !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-33): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-38): 
      will
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-47): 
      simplify
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-52): 
      min
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-54): 
      ..
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-57): 
      max
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-61): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-63): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-66): 
      min
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-68): 
      ..
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (68-71): 
      min
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-74): 
      ] *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (74-75): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 240
    (* [irange] generates a list of int between min and max with an increment of step. *)

  LINE CONTAINS 35 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (5-8): 
      * [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-14): 
      irange
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-25): 
      generates
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-27): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-32): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-39): 
      int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-47): 
      between
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-51): 
      min
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-55): 
      and
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-59): 
      max
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-64): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-67): 
      an
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-77): 
      increment
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (77-78): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (78-80): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-85): 
      step
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-88): 
      . *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (88-89): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 241
    let irange min max step =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-30): 
          let irange min max step =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 242
      let rec loop acc = function i when i=max+1 -> acc | i -> loop ((Int i)::acc) (i+step)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-25): 
            let rec loop acc = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-33): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * storage.type.function.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (34-35): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * entity.name.function.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (36-68): 
      when i=max+1 -> acc | i -> loop 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (68-69): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-70): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (70-73): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-75): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (75-76): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (76-77): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (77-78): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (78-81): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (81-82): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (82-84): 
       (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (84-85): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (85-86): 
      +
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (86-90): 
      step
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (90-91): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 243
      in loop [] min |> List.rev

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
            in loop [] min |> List.rev
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 244
    and frange min max step =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-30): 
          and frange min max step =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 245
      let rec loop acc = function i when i=max+.1. -> acc | i -> loop ((Float i)::acc) (i+.step)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-25): 
            let rec loop acc = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-33): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * storage.type.function.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (34-35): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * entity.name.function.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (36-70): 
      when i=max+.1. -> acc | i -> loop 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (70-71): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (71-72): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (72-77): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (77-78): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (78-79): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (80-81): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (81-82): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (82-85): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (85-86): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (86-88): 
       (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (88-89): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (89-90): 
      +
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (90-91): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * keyword.operator.type.ts
    => TOKEN (91-95): 
      step
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (95-96): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 246
      in loop [] min |> List.rev

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
            in loop [] min |> List.rev
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 247
    in begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-13): 
          in begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 248
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 249
      | Int x, Int y     -> Set (AstSet.of_list (irange x (if !check_only then x else y) 1))

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-32): 
            | Int x, Int y     -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-39): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-47): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-55): 
      irange
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-57): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-59): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (59-61): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-63): 
      !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-73): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-78): 
      then
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (78-79): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (79-80): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-85): 
      else
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (86-87): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (88-93): 
       1))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 250
      | Float x, Float y -> Set (AstSet.of_list (frange x (if !check_only then x else y) 1.))

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-32): 
            | Float x, Float y -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-39): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-47): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-55): 
      frange
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-57): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-59): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (59-61): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-63): 
      !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-73): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-78): 
      then
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (78-79): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (79-80): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-85): 
      else
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (86-87): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (88-94): 
       1.))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 251
      | x',y' -> raise_type_error2 ast x x' y y' "two integers or two floats"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-78): 
            | x',y' -> raise_type_error2 ast x x' y y' "two integers or two floats"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 252
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 253
  | Empty x -> begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Empty x -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 254
      match eval_ast x with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-28): 
            match eval_ast x with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 255
      | Set x -> Bool (AstSet.is_empty x)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-22): 
            | Set x -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-29): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-38): 
      is_empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-40): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 256
      | x' -> raise_type_error ast x x' "a 'float-set', 'int-set' or 'prop-set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-81): 
            | x' -> raise_type_error ast x x' "a 'float-set', 'int-set' or 'prop-set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 257
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 258
  | Card x -> begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-20): 
        | Card x -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 259
      match eval_ast x with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-28): 
            match eval_ast x with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 260
      | Set x -> Int (AstSet.cardinal x)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-21): 
            | Set x -> Int 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-28): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-37): 
      cardinal
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-39): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 261
      | x' -> raise_type_error ast x x' "a 'float-set', 'int-set' or 'prop-set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-81): 
            | x' -> raise_type_error ast x x' "a 'float-set', 'int-set' or 'prop-set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 262
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 263
  | Subset (x,y) -> begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-11): 
        | Subset 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (16-26): 
       -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 264
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 265
      | Set a, Set b -> Bool (AstSet.subset a b)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-29): 
            | Set a, Set b -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-36): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-43): 
      subset
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-45): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-47): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 266
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', int or prop"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-78): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float-set', int or prop"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 267
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 268
  | Powerset x -> begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-24): 
        | Powerset x -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 269
      let combination_to_set k set =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-37): 
            let combination_to_set k set =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 270
        List.fold_left (fun acc x -> AstSet.add (Set (AstSet.of_list x)) acc) AstSet.empty (AstSet.combinations k set)

  LINE CONTAINS 34 TOKENS:
    => TOKEN (0-23): 
              List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-27): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-36): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-43): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (44-47): 
      add
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-52): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-54): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-60): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (61-68): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-70): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (70-71): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (71-91): 
      ) acc) AstSet.empty 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (91-92): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (92-98): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (98-99): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (99-111): 
      combinations
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (111-112): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (112-113): 
      k
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (113-114): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (114-117): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (117-118): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 271
      in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-9): 
            in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 272
      let rec all_combinations_to_set k set = match k with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-59): 
            let rec all_combinations_to_set k set = match k with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 273
        (* 0 -> because AstSet.combinations does not produce the empty set

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-15): 
      * 0 ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-23): 
      because
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-30): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-43): 
      combinations
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      does
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-52): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-60): 
      produce
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (61-64): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-70): 
      empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (70-71): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (71-74): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,41] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 274
                in the set of combinations, we must add the empty set here. *)

  LINE CONTAINS 27 TOKENS:
    => TOKEN (0-16): 
                      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-22): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-26): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-29): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-42): 
      combinations
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-46): 
      we
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      must
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-55): 
      add
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-59): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-65): 
      empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (65-66): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (66-69): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-74): 
      here
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-77): 
      . *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (77-78): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 275
        | 0 -> AstSet.of_list [Set (AstSet.empty)]

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-35): 
              | 0 -> AstSet.of_list [Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (36-42): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-48): 
      empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-51): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 276
        | _ -> AstSet.union (combination_to_set k set) (all_combinations_to_set (pred k) set)

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-28): 
              | _ -> AstSet.union 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-47): 
      combination_to_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      k
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (55-56): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (56-79): 
      all_combinations_to_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (80-81): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (81-85): 
      pred
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (86-87): 
      k
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (88-94): 
       set)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 277
      in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-9): 
            in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 278
      match eval_ast x with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-28): 
            match eval_ast x with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 279
      (* !check_only is here to skip the full expansion of powerset(). This

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-10): 
      * !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-20): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      here
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-31): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-36): 
      skip
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-40): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-45): 
      full
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-55): 
      expansion
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-58): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-67): 
      powerset
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (68-69): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-76): 
      . This
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 280
         is useful for linting (=checking types). *)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-31): 
               is useful for linting 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (32-33): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (33-47): 
      checking types
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-53): 
      . *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 281
      | Set s -> if !check_only then Set (AstSet.of_list [AstSet.choose s])

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-41): 
            | Set s -> if !check_only then Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (41-42): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-48): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-56): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-58): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (58-64): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (65-71): 
      choose
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-73): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (74-75): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 282
                 else Set (all_combinations_to_set (AstSet.cardinal s) s)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-26): 
                       else Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-50): 
      all_combinations_to_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-52): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (52-58): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (59-67): 
      cardinal
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-69): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (70-74): 
       s)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 283
      | x' -> raise_type_error ast x x' "a 'set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-50): 
            | x' -> raise_type_error ast x x' "a 'set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 284
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 285
  | In (x,y) ->

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-7): 
        | In 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-9): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-16): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 286
    begin match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-44): 
          begin match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 287
      | x', Set y' -> Bool (AstSet.mem x' y')

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-27): 
            | x', Set y' -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (27-28): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-34): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-38): 
      mem
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-40): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-43): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 288
      | x',y' -> raise_type_error2 ast x x' y y' "an 'int', 'float' or 'prop' on the left-hand and a 'set' on the right-hand"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-126): 
            | x',y' -> raise_type_error2 ast x x' y y' "an 'int', 'float' or 'prop' on the left-hand and a 'set' on the right-hand"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 289
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 290
  | Equal (x,y) -> begin match eval_ast x, eval_ast y with

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
        | Equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-59): 
       -> begin match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 291
      | Int x, Int y -> Bool (x = y)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-29): 
            | Int x, Int y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (33-35): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 292
      | Float x, Float y -> Bool (x = y)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-33): 
            | Float x, Float y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (37-39): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 293
      | Prop x, Prop y -> Bool (x = y)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-31): 
            | Prop x, Prop y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (35-37): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 294
      | Set a, Set b -> Bool (AstSet.equal a b)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-29): 
            | Set a, Set b -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-36): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-42): 
      equal
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 295
      | x',y' -> raise_type_error2 ast x x' y y' "an 'int', 'float', 'prop' or 'set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-86): 
            | x',y' -> raise_type_error2 ast x x' y y' "an 'int', 'float', 'prop' or 'set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 296
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 297
  | Not_equal (x,y) -> eval_ast (Not (Equal (x,y)))

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-14): 
        | Not_equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-32): 
       -> eval_ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-36): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-38): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-43): 
      Equal
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-45): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-52): 
      ))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 298
  | Lesser_than (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-16): 
        | Lesser_than 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-18): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-25): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-31): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-40): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-42): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-52): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-54): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-59): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,42] BeginEndRule "meta.function.type.parameter.ts", entered @21
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 299
      | Int x, Int y -> Bool (x < y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 300
      | Float x, Float y -> Bool (x < y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-33): 
            | Float x, Float y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-39): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 301
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 302
  | Lesser_or_equal (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-20): 
        | Lesser_or_equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-22): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (25-29): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-35): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-56): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-58): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-63): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,43] BeginEndRule "meta.function.type.parameter.ts", entered @25
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 303
      | Int x, Int y -> Bool (x <= y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (34-36): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 304
      | Float x, Float y -> Bool (x <= y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-33): 
            | Float x, Float y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (38-40): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 305
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 306
  | Greater_than     (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-21): 
        | Greater_than     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-30): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-36): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-45): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-47): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-57): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-59): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-64): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,44] BeginEndRule "meta.function.type.parameter.ts", entered @26
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 307
      | Int x, Int y -> Bool (x > y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 308
      | Float x, Float y -> Bool (x > y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-33): 
            | Float x, Float y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-39): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 309
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 310
  | Greater_or_equal (x,y) -> (match eval_ast x, eval_ast y with

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-21): 
        | Greater_or_equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-30): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-36): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-45): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-47): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-57): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-59): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-64): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,45] BeginEndRule "meta.function.type.parameter.ts", entered @26
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 311
      | Int x, Int y -> Bool (x >= y)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
            |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      Bool
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (34-36): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 312
      | Float x, Float y -> Bool (x >= y)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-33): 
            | Float x, Float y -> Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (38-40): 
       y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 313
      | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
            | x',y' -> raise_type_error2 ast x x' y y' "a 'float' or 'int'")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 314
  | UnexpProp (p,i) -> expand_prop_with_set env  p i

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
        | UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-53): 
       -> expand_prop_with_set env  p i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 315
  | Prop x -> Prop x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Prop x -> Prop x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 316
  | Loc (x,l) -> eval_ast x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | Loc 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      l
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-28): 
       -> eval_ast x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 317
  | Paren x -> eval_ast x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-26): 
        | Paren x -> eval_ast x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 318
  | e -> failwith ("[shouldnt happen] this expression cannot be expanded: " ^ string_of_ast e ^"\n")

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-18): 
        | e -> failwith 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-21): 
      "[
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-29): 
      shouldnt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-36): 
      happen
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-42): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-53): 
      expression
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-60): 
      cannot
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (61-63): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-72): 
      expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (72-73): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (74-75): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (75-95): 
       ^ string_of_ast e ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (95-96): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (96-97): 
      \
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (97-98): 
      n
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (98-99): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (99-100): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,46] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 319
  in expanded

  LINE CONTAINS 4 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (2-4): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-13): 
      expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,46] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 320


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,46] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 321
and eval_set_decl (env:env) (set_decl:Ast.t) =

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-3): 
      and
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (4-17): 
      eval_set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-22): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (23-26): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (26-27): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-37): 
      set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (38-43): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (43-44): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-47): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 322
  let sets = (match ast_without_loc set_decl with Set_decl sets -> sets | _ -> failwith "shoulnt happen: non-Set_decl in eval_set_decl") in

  LINE CONTAINS 42 TOKENS:
    => TOKEN (0-13): 
        let sets = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-19): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-35): 
      ast_without_loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-44): 
      set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-49): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-58): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-63): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-66): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-71): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-73): 
      |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-75): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (75-76): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (76-78): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (78-79): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (79-87): 
      failwith
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (88-89): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (89-96): 
      shoulnt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (96-97): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (97-103): 
      happen
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (103-104): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (104-105): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (105-108): 
      non
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (108-109): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (109-117): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (117-118): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (118-120): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * keyword.others.ts
    => TOKEN (120-121): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (121-134): 
      eval_set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (134-135): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (135-138): 
      ) i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (138-139): 
      n
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 323
  let sets_expanded = List.map (fun x -> eval_ast env x) sets in

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-19): 
      sets_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (21-31): 
       List.map 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.paren.ts
    => TOKEN (32-38): 
      fun x 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-39): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (39-40): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (40-55): 
       eval_ast env x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.paren.ts
    => TOKEN (56-62): 
       sets 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-64): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 324
  let unwrap_set first_elmt elmt elmt_expanded = match first_elmt, elmt_expanded with

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-16): 
      unwrap_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-27): 
      first_elmt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-32): 
      elmt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-46): 
      elmt_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-48): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (48-65): 
       match first_elmt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (65-66): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-80): 
      elmt_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-85): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 325
    | Int _  , Int x   -> Int x

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-5): 
          |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-9): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-13): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-23): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      Int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 326
    | Float _, Float x -> Float x

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-5): 
          |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-11): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-20): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-22): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-31): 
      Float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-33): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 327
    | Prop _ , Prop x  -> Prop x

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-5): 
          |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-10): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-12): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-19): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-23): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-30): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 328
    | Set _  , Set x   -> Set x

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-5): 
          |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-9): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-13): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-23): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 329
    | _ -> raise_set_decl set_decl elmt elmt_expanded

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-5): 
          |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-7): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-10): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-25): 
      raise_set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-34): 
      set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-39): 
      elmt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-53): 
      elmt_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,47] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 330
             (Set_decl sets) (Set_decl sets_expanded)

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-14): 
                   (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-22): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-27): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-38): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-52): 
      sets_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 331
             ("at this point a comma-separated list of '"^string_of_ast_type first_elmt^"', \

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-13): 
                   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-15): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-17): 
      at
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-22): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-28): 
      point
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-36): 
      comma
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-46): 
      separated
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-51): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-54): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-58): 
      '"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (58-76): 
      string_of_ast_type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-87): 
      first_elmt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-94): 
      ^"', \
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,48] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 332
             because previous elements of the list had this type"^"\n")

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-13): 
                   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-20): 
      because
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-29): 
      previous
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-38): 
      elements
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-41): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-45): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-50): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-54): 
      had
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-59): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-64): 
      type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-68): 
      "^"\
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (68-69): 
      n
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (70-71): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 333
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 334
  match sets, sets_expanded with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
        match sets, sets_expanded with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 335
  | [],[] -> Set AstSet.empty

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-30): 
        | [],[] -> Set AstSet.empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 336
  | x::_,first::_ -> begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
        | x::_,first::_ -> begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 337
      match first with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
            match first with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 338
      | Int _ | Float _ | Prop _ | Set _ -> Set (AstSet.of_list (List.map2 (unwrap_set first) sets sets_expanded))

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-48): 
            | Int _ | Float _ | Prop _ | Set _ -> Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-55): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (56-63): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-65): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (65-69): 
      List
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (70-74): 
      map2
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-75): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (75-76): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (76-86): 
      unwrap_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (87-92): 
      first
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (92-93): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (93-115): 
       sets sets_expanded))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 339
      | _ -> raise_set_decl set_decl x first

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-45): 
            | _ -> raise_set_decl set_decl x first
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 340
                    (Set_decl sets) (Set_decl sets_expanded)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-20): 
                          
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-29): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-34): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-45): 
      Set_decl
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-59): 
      sets_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 341
                    "elements of type 'int', 'float', 'prop' or 'set'"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-71): 
                          "elements of type 'int', 'float', 'prop' or 'set'"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 342
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 343
  | [],x::_ | x::_,[] -> failwith "[shouldn't happen] len(sets)!=len(sets_expanded)"

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-57): 
        | [],x::_ | x::_,[] -> failwith "[shouldn't happen] len
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (57-58): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (58-62): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (63-68): 
      !=len
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (68-69): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-82): 
      sets_expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (82-83): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (83-85): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 344


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 345


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 346
(* [eval_ast_formula] evaluates formulas; nothing in formulas should be

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (1-4): 
      * [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-20): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-31): 
      evaluates
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-40): 
      formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      ;
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-49): 
      nothing
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-52): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-61): 
      formulas
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-68): 
      should
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-71): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,49] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 347
   expanded, except for variables, bigand, bigor, let, exact, atleast,atmost. *)

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (3-11): 
      expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-19): 
      except
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-23): 
      for
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-33): 
      variables
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-41): 
      bigand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-48): 
      bigor
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-60): 
      exact
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-69): 
      atleast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (70-76): 
      atmost
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-79): 
      . *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (79-80): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 348
and eval_ast_formula (env:env) (ast:Ast.t) : Ast.t =

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-21): 
      and eval_ast_formula 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-25): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (26-29): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (32-35): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (36-41): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-44): 
       :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (45-50): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (50-52): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 349
  let eval_ast_formula = eval_ast_formula env

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-46): 
        let eval_ast_formula = eval_ast_formula env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 350
  and eval_ast_formula_env = eval_ast_formula

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-46): 
        and eval_ast_formula_env = eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 351
  and eval_ast = eval_ast env in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
        and eval_ast = eval_ast env in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 352
  match ast_without_loc ast with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
        match ast_without_loc ast with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 353
  | Int x   -> Int x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Int x   -> Int x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 354
  | Float x -> Float x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
        | Float x -> Float x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 355
  | Neg x ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-13): 
        | Neg x ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 356
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 357
      match eval_ast_formula x with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-36): 
            match eval_ast_formula x with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 358
      | Int   x' -> Int   (- x')

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-26): 
            | Int   x' -> Int   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-28): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 359
      | Float x' -> Float (-. x')

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-26): 
            | Float x' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-29): 
      -.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 360
      | x' -> Neg x'

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
            | x' -> Neg x'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 361
      (*| _ -> raise (Error (string_of_ast ast))*)

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-14): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-20): 
      raise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-27): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-42): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-46): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (47-51): 
      )*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 362
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 363
  | Add (x,y) ->

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | Add 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 364
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 365
      match eval_ast_formula x, eval_ast_formula y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-56): 
            match eval_ast_formula x, eval_ast_formula y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 366
      | Int x', Int y'     -> Int   (x' +  y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Int x', Int y'     -> Int   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-41): 
      ' +
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-43): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 367
      | Float x', Float y' -> Float (x' +. y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Float x', Float y' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-42): 
      ' +.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 368
      | Int _, Prop _

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-22): 
            | Int _, Prop _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 369
      | Prop _, Int _ -> Add (x,y)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-29): 
            | Prop _, Int _ -> Add 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-31): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 370
      | x', y' -> Add (x', y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-22): 
            | x', y' -> Add 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-24): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-26): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-28): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 371
      (*| _,_ -> raise (Error (string_of_ast ast))*)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      raise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-29): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-44): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-53): 
      )*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 372
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 373
  | Sub (x,y) ->

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | Sub 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 374
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 375
      match eval_ast_formula x, eval_ast_formula y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-56): 
            match eval_ast_formula x, eval_ast_formula y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 376
      | Int x', Int y'     -> Int   (x' -  y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Int x', Int y'     -> Int   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-41): 
      ' -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-43): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 377
      | Float x', Float y' -> Float (x' -. y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Float x', Float y' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-42): 
      ' -.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 378
      (*| Prop x', Prop x' -> Sub (Prop x', Prop x')*)

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-14): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-18): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-23): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-29): 
      ' ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-33): 
      Sub
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-39): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-43): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-50): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (52-55): 
      *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 379
      | x', y' -> Sub (x', y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-22): 
            | x', y' -> Sub 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-24): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-26): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-28): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 380
      (*| _,_ -> raise (Error (string_of_ast ast))*)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      raise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-29): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-44): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-53): 
      )*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 381
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 382
  | Mul (x,y) ->

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | Mul 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 383
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 384
      match eval_ast_formula x, eval_ast_formula y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-56): 
            match eval_ast_formula x, eval_ast_formula y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 385
      | Int x', Int y'     -> Int   (x' *  y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Int x', Int y'     -> Int   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-41): 
      ' *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-43): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 386
      | Float x', Float y' -> Float (x' *. y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Float x', Float y' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-42): 
      ' *.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 387
      | x', y' -> Mul (x', y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-22): 
            | x', y' -> Mul 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-24): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-26): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-28): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 388
      (*| _,_ -> raise (Error (string_of_ast ast))*)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      raise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-29): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-44): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-53): 
      )*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 389
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 390
  | Div (x,y) ->

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | Div 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 391
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 392
      match eval_ast_formula x, eval_ast_formula y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-56): 
            match eval_ast_formula x, eval_ast_formula y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 393
      | Int x', Int y'     -> Int   (x' /  y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Int x', Int y'     -> Int   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-41): 
      ' /
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-43): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 394
      | Float x', Float y' -> Float (x' /. y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-36): 
            | Float x', Float y' -> Float 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-38): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-42): 
      ' /.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 395
      | x', y' -> Div (x', y')

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-22): 
            | x', y' -> Div 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-24): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-26): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-28): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 396
      (*| _,_ -> raise (Error (string_of_ast ast))*)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-9): 
      *|
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      raise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-29): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-44): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-53): 
      )*)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 397
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 398
  | Equal            (x,y) -> Equal            (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Equal            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Equal            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 399
  | Not_equal        (x,y) -> Not_equal        (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Not_equal        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Not_equal        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 400
  | Lesser_than      (x,y) -> Lesser_than      (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Lesser_than      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Lesser_than      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 401
  | Lesser_or_equal  (x,y) -> Lesser_or_equal  (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Lesser_or_equal  
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Lesser_or_equal  
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 402
  | Greater_than     (x,y) -> Greater_than     (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Greater_than     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Greater_than     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 403
  | Greater_or_equal (x,y) -> Greater_or_equal (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-21): 
        | Greater_or_equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-47): 
       -> Greater_or_equal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-84): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 404
  | Top    -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-18): 
        | Top    -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 405
  | Bottom -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Bottom -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 406
  | UnexpProp (p,i) -> Prop (expand_var_name env (p,i))

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-14): 
        | UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-28): 
       -> Prop 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-44): 
      expand_var_name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-50): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (50-51): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (52-53): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (54-56): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 407
  | Prop x -> Prop x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
        | Prop x -> Prop x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 408
  | Var (p,i) -> (* p,i = prefix,indices *)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-8): 
        | Var 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-17): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-19): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-25): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (25-32): 
       prefix
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-40): 
      indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-42): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 409
    (* name = prefix + indices.

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (5-6): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (6-7): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (7-11): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (13-21): 
       prefix 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-22): 
      +
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (22-31): 
       indices.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,50] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 410
       Example with $v(a,b,c):

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-7): 
             
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (7-14): 
      Example
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-19): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-22): 
      $v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (27-28): 
      c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-30): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 411
       name is '$v(a,b,c)', prefix is '$v' and indices are '(a,b,c)' *)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-18): 
             name is '$v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-20): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-22): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
      c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (25-60): 
      ', prefix is '$v' and indices are '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (60-61): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (61-62): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-64): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (65-66): 
      c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (67-72): 
      ' *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 412
    let name = expand_var_name env (p,i) in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-35): 
          let name = expand_var_name env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (36-37): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-39): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (40-44): 
       in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 413
    begin

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 414
      (* Case 1. Check if this variable name has been affected locally

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-8): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-9): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-13): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      1.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      Check
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-30): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-39): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-44): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-53): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-62): 
      affected
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-70): 
      locally
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,51] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 415
         (recursive-wise) in bigand, bigor or let.

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-10): 
               (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-19): 
      recursive
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-24): 
      wise
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (25-51): 
       in bigand, bigor or let.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 416
         To be accepted, this variable must contain a proposition. *)

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-70): 
               To be accepted, this variable must contain a proposition. *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 417
      try let content,loc_affect = List.assoc name env in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-58): 
            try let content,loc_affect = List.assoc name env in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 418
        match content with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
              match content with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 419
        | Prop x -> Prop x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
              | Prop x -> Prop x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 420
        | Int x when !smt -> Int x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-35): 
              | Int x when !smt -> Int x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 421
        | Float x when !smt -> Float x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-39): 
              | Float x when !smt -> Float x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 422
        | _ -> raise_with_loc ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-34): 
              | _ -> raise_with_loc ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 423
            ("local variable '" ^ name ^ "' (defined in bigand, bigor or let) "^

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-19): 
      local
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-28): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-33): 
      '" ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-38): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-45): 
      ^ "' (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-52): 
      defined
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-55): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-62): 
      bigand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-69): 
      bigor
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-72): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (73-76): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (77-81): 
       "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 424
            "cannot be expanded into a 'prop' because its content "^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-69): 
                  "cannot be expanded into a 'prop' because its content "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 425
            "is of type '"^(string_of_ast_type content)^"' instead of "^

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-27): 
                  "is of type '"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (27-28): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-46): 
      string_of_ast_type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-54): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (55-73): 
      ^"' instead of "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 426
              (if !smt then "'prop', 'int' or 'float'" else "'prop'") ^ ". "^

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-14): 
                    
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-17): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-19): 
      !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-22): 
      smt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-27): 
      then
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-30): 
      "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-34): 
      prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-38): 
      ', '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-41): 
      int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-45): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-47): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-52): 
      float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-54): 
      '"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-59): 
      else
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-62): 
      "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-66): 
      prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-68): 
      '"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (68-69): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-78): 
       ^ ". "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 427
            "Why? Because this variable is part of a formula, and thus is expected"^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-85): 
                  "Why? Because this variable is part of a formula, and thus is expected"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 428
            "to be a proposition. Here is the content of '" ^name^"':\n"^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-74): 
                  "to be a proposition. Here is the content of '" ^name^"':\n"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 429
            "    "^(string_of_ast content)^"\n")

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-19): 
                  "    "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-33): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-41): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-49): 
      ^"\n")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 430
      with Not_found ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-24): 
            with Not_found ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 431
      (* Case 2. Check if this variable name has been affected globally, i.e.,

  LINE CONTAINS 31 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-8): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-9): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-13): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      2.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-22): 
      Check
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-30): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-39): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-44): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-48): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-53): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-62): 
      affected
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-71): 
      globally
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (73-74): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-75): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (75-76): 
      e
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-79): 
      .,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,52] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 432
         in the 'data' section. To be accepted, this variable must contain

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-9): 
               
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-11): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-15): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-17): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-21): 
      data
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-30): 
      section
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-34): 
      To
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-37): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-46): 
      accepted
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-52): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-61): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-66): 
      must
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-74): 
      contain
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,52] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 433
         a proposition. *)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-9): 
               
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-10): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-22): 
      proposition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-25): 
      . *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 434
      try let content,loc_affect = Hashtbl.find !extenv name in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-64): 
            try let content,loc_affect = Hashtbl.find !extenv name in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 435
        match content with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
              match content with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 436
        | Prop x -> Prop x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
              | Prop x -> Prop x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 437
        | Int x when !smt -> Int x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-35): 
              | Int x when !smt -> Int x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 438
        | Float x when !smt -> Float x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-39): 
              | Float x when !smt -> Float x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 439
        | _ -> raise_with_loc ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-34): 
              | _ -> raise_with_loc ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 440
            ("global variable '" ^ name ^ "' cannot be expanded into a 'prop' "^

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-20): 
      global
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-29): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-34): 
      '" ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-39): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-44): 
      ^ "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-51): 
      cannot
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-54): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-63): 
      expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-68): 
      into
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-70): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (70-71): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (71-72): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (72-76): 
      prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-81): 
      ' "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,53] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 441
            "because its content is of type '"^(string_of_ast_type content)^"' instead of "^

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-13): 
                  "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-20): 
      because
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-24): 
      its
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-32): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-38): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-43): 
      type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-48): 
      '"^(
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (48-66): 
      string_of_ast_type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-74): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-75): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (75-93): 
      ^"' instead of "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 442
               (if !smt then "'prop', 'int' or 'float'" else "'prop'") ^ ". "^

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-15): 
                     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (15-16): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (16-18): 
      if
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-20): 
      !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-23): 
      smt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-28): 
      then
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-31): 
      "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-35): 
      prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-39): 
      ', '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-42): 
      int
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-46): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-48): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (48-53): 
      float
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-55): 
      '"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-60): 
      else
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (61-63): 
      "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (63-67): 
      prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-69): 
      '"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (69-70): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (70-79): 
       ^ ". "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 443
            "Why? Because this variable is part of a formula, and thus is expected "^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-86): 
                  "Why? Because this variable is part of a formula, and thus is expected "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 444
            "to be a proposition. Here is the content of '" ^name^"':\n"^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-74): 
                  "to be a proposition. Here is the content of '" ^name^"':\n"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 445
            "    "^(string_of_ast content)^"\n")

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-19): 
                  "    "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (19-20): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-33): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-41): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-49): 
      ^"\n")
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 446
      with Not_found ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-24): 
            with Not_found ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 447
      try

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
            try
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 448
        match (p,i) with

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
              match 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-25): 
       with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 449
        (* Case 3. The variable is a non-tuple of the form '$v' => name=prefix only.

  LINE CONTAINS 34 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-15): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      3.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-22): 
      The
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-31): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-34): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-40): 
      non
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-46): 
      tuple
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-49): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-58): 
      form
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-60): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (60-62): 
      $v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-64): 
      ' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (64-65): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (65-66): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (66-71): 
       name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (71-72): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (72-84): 
      prefix only.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,54] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 450
           As it has not been found in the Case 1 or 2, this means that this variable

  LINE CONTAINS 34 TOKENS:
    => TOKEN (0-11): 
                 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-13): 
      As
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      it
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-20): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-24): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-29): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-35): 
      found
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-38): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-42): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-47): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      1
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-52): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-55): 
      2,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-60): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (61-66): 
      means
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-71): 
      that
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-76): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-85): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,54] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 451
           has not been declared. *)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-11): 
                 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-14): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-18): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-23): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      declared
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-35): 
      . *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 452
        | prefix, None -> raise Not_found (* trick to go to the Case 5. error *)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-42): 
              | prefix, None -> raise Not_found 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (42-43): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (43-44): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-50): 
      trick
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-53): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-56): 
      go
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-59): 
      to
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-63): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-68): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-71): 
      5.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-77): 
      error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (77-78): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (78-79): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (79-80): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 453
        (* Case 4. The var is a tuple-variable of the form '$v(1,2,3)' and has not

  LINE CONTAINS 31 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-15): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (16-18): 
      4.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-22): 
      The
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-26): 
      var
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-29): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-37): 
      tuple
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-46): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-49): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-58): 
      form
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-60): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (60-62): 
      $v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-68): 
      (1,2,3
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (68-69): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-83): 
      ' and has not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 454
           been declared.

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-26): 
                 been declared.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 455
           But maybe we are in the following special case where the parenthesis

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-80): 
                 But maybe we are in the following special case where the parenthesis
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 456
           in $v(a,b,c) that should let think it is a tuple-variable is actually

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-16): 
                 in $v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-18): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-22): 
      c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-81): 
       that should let think it is a tuple-variable is actually
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 457
           a 'reconstructed' term, e.g. the content of $v should be expanded.

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-78): 
                 a 'reconstructed' term, e.g. the content of $v should be expanded.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 458
           Example of use:

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
                 Example of use:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 459
            $F = [a,b,c]

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-25): 
                  $F = [a,b,c]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 460
            bigand $i in [1..3]:

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
                  bigand $i in [1..3]:
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 461
              bigand $f in $F:     <- $f is defined as non-tuple variable (= no indices)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-35): 
                    bigand $f in $F:     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.brace.angle.ts
    => TOKEN (36-38): 
      - 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (38-40): 
      $f
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (41-43): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (43-44): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (44-51): 
      defined
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (52-54): 
      as
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (55-58): 
      non
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (58-59): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (59-64): 
      tuple
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (65-73): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (73-75): 
       (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts
    => TOKEN (75-77): 
      = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts
    => TOKEN (77-79): 
      no
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (79-80): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts
    => TOKEN (80-87): 
      indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.paren.cover.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 462
                $f($i)             <- here, $f looks like a tuple-variable but NO!

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-18): 
                      $f
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-21): 
      $i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-35): 
                   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      <
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.brace.angle.ts
    => TOKEN (36-38): 
      - 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (38-42): 
      here
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (42-44): 
      , 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (44-46): 
      $f
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (47-52): 
      looks
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (53-57): 
      like
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (58-59): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (60-65): 
      tuple
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (65-66): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (66-74): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (74-75): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (75-78): 
      but
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (78-79): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
    => TOKEN (79-81): 
      NO
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts
      * meta.type.name.ts
    => TOKEN (81-82): 
      !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.type.parameters.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 463
              end                     It is simply used to form the proposition

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-80): 
                    end                     It is simply used to form the proposition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 464
            end                       a(1), a(2)..., b(1)...    *)

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-39): 
                  end                       a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (39-40): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (40-41): 
      1
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-45): 
      , a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (45-46): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (46-47): 
      2
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-54): 
      ..., b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (54-55): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (55-56): 
      1
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (56-57): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (57-67): 
      ...    *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 465
        | prefix, Some indices ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-34): 
              | prefix, Some indices ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 466
          let (content,loc_affect) = List.assoc prefix env in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
                let 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-22): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-33): 
      loc_affect
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-62): 
       = List.assoc prefix env in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 467
          let term = match content with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
                let term = match content with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 468
            | Prop x -> Prop x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-31): 
                  | Prop x -> Prop x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 469
            | wrong -> fatal (Error,Eval,

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-29): 
                  | wrong -> fatal 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-35): 
      Error
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-40): 
      Eval
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-42): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,55] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 470
                "the proposition '" ^ name ^ "' cannot be expanded because '"^prefix^"' is of type '"^(string_of_ast_type wrong)^"'. " ^

  LINE CONTAINS 35 TOKENS:
    => TOKEN (0-17): 
                      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-20): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-32): 
      proposition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-37): 
      '" ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-42): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-47): 
      ^ "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-54): 
      cannot
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-57): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-66): 
      expanded
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-74): 
      because
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-75): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (75-78): 
      '"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (78-84): 
      prefix
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-87): 
      ^"'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (87-88): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (88-90): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (90-91): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (91-93): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (93-94): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (94-98): 
      type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (98-99): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (99-103): 
      '"^(
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (103-121): 
      string_of_ast_type
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (121-122): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (122-127): 
      wrong
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (127-128): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (128-137): 
      ^"'. " ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 471
                "In order to produce an expanded proposition of this kind, '"^prefix^"' must be a proposition. "^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-114): 
                      "In order to produce an expanded proposition of this kind, '"^prefix^"' must be a proposition. "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 472
                "Why? Because this variable is part of a formula, and thus is expected "^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-90): 
                      "Why? Because this variable is part of a formula, and thus is expected "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 473
                "to be a proposition. Here is the content of '" ^prefix^"':\n"^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-80): 
                      "to be a proposition. Here is the content of '" ^prefix^"':\n"^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 474
                "    "^(string_of_ast content)^"\n",Some loc_affect)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
                      "    "^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-37): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-45): 
      content
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (46-69): 
      ^"\n",Some loc_affect)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 475
          in eval_ast_formula (UnexpProp ((string_of_ast term), Some indices))

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-30): 
                in eval_ast_formula 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-40): 
      UnexpProp
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-43): 
      ((
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-56): 
      string_of_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-61): 
      term
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (62-79): 
      , Some indices))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 476
      (* Case 5. the variable was of the form '$v(1,2,3)' and was not declared

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-8): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-9): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-13): 
      Case
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      5.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-20): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-29): 
      variable
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-33): 
      was
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-36): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-40): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-45): 
      form
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-47): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-49): 
      $v
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-55): 
      (1,2,3
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (55-56): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (56-79): 
      ' and was not declared
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 477
         and '$v' is not either declared, so we can safely guess that this var has not been declared. *)

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-105): 
               and '$v' is not either declared, so we can safely guess that this var has not been declared. *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 478
      with Not_found -> raise_with_loc ast ("'" ^ name ^ "' has not been declared"^"\n")

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-43): 
            with Not_found -> raise_with_loc ast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-49): 
      "'" ^
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-54): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-59): 
      ^ "'
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-63): 
      has
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-67): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-72): 
      been
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (73-81): 
      declared
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (81-85): 
      "^"\
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (85-86): 
      n
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (86-87): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 479
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 480
  | Not Top    -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-25): 
        | Not Top    -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 481
  | Not Bottom -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-22): 
        | Not Bottom -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 482
  | Not x      -> Not (eval_ast_formula x)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-22): 
        | Not x      -> Not 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-39): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 483
  | And (Bottom, _) | And (_, Bottom) -> Bottom

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-8): 
        | And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-15): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-18): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-26): 
       | And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (26-27): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (27-28): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-36): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-48): 
       -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 484
  | And (Top,x)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-8): 
        | And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-12): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 485
  | And (x,Top) -> eval_ast_formula x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        | And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-10): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-14): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-38): 
       -> eval_ast_formula x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 486
  | And     (x,y) -> And (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
        | And     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-25): 
       -> And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-42): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-62): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-64): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 487
  | Or (Top, _) | Or (_, Top) -> Top

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-7): 
        | Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-11): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-14): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-21): 
       | Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-28): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-37): 
       -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 488
  | Or (Bottom,x)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-7): 
        | Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-14): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 489
  | Or (x,Bottom) -> eval_ast_formula x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-7): 
        | Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (8-9): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-16): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-40): 
       -> eval_ast_formula x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 490
  | Or      (x,y) -> Or  (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
        | Or      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-25): 
       -> Or  
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-42): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-62): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-64): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 491
  | Xor     (x,y) -> Xor (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
        | Xor     
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-25): 
       -> Xor 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-42): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-44): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-62): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-64): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 492
  | Implies (_,Top)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-18): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 493
  | Implies (Bottom,_) -> Top

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-19): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-30): 
       -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 494
  | Implies (x,Bottom) -> eval_ast_formula (Not x)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-21): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-43): 
       -> eval_ast_formula 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-47): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 495
  | Implies (Top,x) -> eval_ast_formula x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-16): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-42): 
       -> eval_ast_formula x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 496
  | Implies (x,y) -> Implies (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
        | Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-29): 
       -> Implies 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-46): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-48): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-66): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (67-68): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 497
  | Equiv   (x,Top) (* x      (x  )  (  x)      x    x *)

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-12): 
        | Equiv   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-18): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-22): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-24): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-35): 
           (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (41-44): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (44-45): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (45-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-51): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (52-72): 
            x    x *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 498
  | Equiv   (Top,x) -> eval_ast_formula x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-12): 
        | Equiv   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-16): 
      Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-42): 
       -> eval_ast_formula x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 499
  | Equiv   (x,Bottom) (* x      (x  )  (  x)    x      x *)

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-12): 
        | Equiv   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-21): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-27): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-38): 
           (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-39): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-47): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (48-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-54): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (55-77): 
          x      x *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 500
  | Equiv   (Bottom,x) -> eval_ast_formula (Not x)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-12): 
        | Equiv   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-19): 
      Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-43): 
       -> eval_ast_formula 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-47): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-49): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 501
  | Equiv   (x,y) -> Equiv (eval_ast_formula x, eval_ast_formula y)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
        | Equiv   
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-27): 
       -> Equiv 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (27-28): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-44): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-64): 
      eval_ast_formula
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-66): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 502
  | Exact (x,y) -> rm_top_bot begin (* !check_only simplifies by returning a dummy proposition *)

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-10): 
        | Exact 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-36): 
       -> rm_top_bot begin 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (37-40): 
      * !
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-50): 
      check_only
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-61): 
      simplifies
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-64): 
      by
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-74): 
      returning
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (74-75): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (75-76): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-82): 
      dummy
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (82-83): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (83-94): 
      proposition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (94-95): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (95-96): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (96-97): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 503
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 504
      | Int 0, Set s when AstSet.is_empty s -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-51): 
            | Int 0, Set s when AstSet.is_empty s -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 505
      | Int k, Set s when AstSet.is_empty s -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-54): 
            | Int k, Set s when AstSet.is_empty s -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 506
      | Int x, Set s -> if !check_only then Prop "dummy" else exact_str (AstSet.exact x s)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-72): 
            | Int x, Set s -> if !check_only then Prop "dummy" else exact_str 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (72-73): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (73-79): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (80-85): 
      exact
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (86-87): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (88-89): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (89-90): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 507
      | x',y' -> raise_type_error2 ast x x' y y' "'int' (left-hand) and a 'prop-set' (right-hand)"

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-56): 
            | x',y' -> raise_type_error2 ast x x' y y' "'int' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (56-57): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (57-61): 
      left
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-66): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (67-85): 
       and a 'prop-set' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (85-86): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (86-91): 
      right
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (91-92): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (92-96): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (96-97): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (97-99): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 508
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 509
  | Atleast (x,y) -> rm_top_bot begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-12): 
        | Atleast 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (12-13): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-38): 
       -> rm_top_bot begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 510
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 511
      | Int 0, Set s when AstSet.is_empty s -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-51): 
            | Int 0, Set s when AstSet.is_empty s -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 512
      | Int k, Set s when k > 0 && AstSet.is_empty s -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-63): 
            | Int k, Set s when k > 0 && AstSet.is_empty s -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 513
      | Int x, Set s -> if !check_only then Prop "dummy" else atleast_str (AstSet.atleast x s)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-74): 
            | Int x, Set s -> if !check_only then Prop "dummy" else atleast_str 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (74-75): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (75-81): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (81-82): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (82-89): 
      atleast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (89-90): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (90-91): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (91-92): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (92-93): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (93-94): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 514
      | x',y' -> raise_type_error2 ast x x' y y' "'int' (left-hand) and a 'prop-set' (right-hand)"

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-56): 
            | x',y' -> raise_type_error2 ast x x' y y' "'int' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (56-57): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (57-61): 
      left
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-66): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (67-85): 
       and a 'prop-set' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (85-86): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (86-91): 
      right
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (91-92): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (92-96): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (96-97): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (97-99): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 515
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 516
  | Atmost (x,y) -> rm_top_bot begin

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-11): 
        | Atmost 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-13): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (16-37): 
       -> rm_top_bot begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 517
      match eval_ast x, eval_ast y with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-40): 
            match eval_ast x, eval_ast y with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 518
      | Int _, Set s when AstSet.is_empty s -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-51): 
            | Int _, Set s when AstSet.is_empty s -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 519
      | Int 0, Set _ -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-31): 
            | Int 0, Set _ -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 520
      | Int x, Set s -> if !check_only then Prop "dummy" else atmost_str (AstSet.atmost x s)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-73): 
            | Int x, Set s -> if !check_only then Prop "dummy" else atmost_str 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (73-74): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (74-80): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (81-87): 
      atmost
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (88-89): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (89-90): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (90-91): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (91-92): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 521
      | x',y' -> raise_type_error2 ast x x' y y' "'int' (left-hand) and a 'prop-set' (right-hand)"

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-56): 
            | x',y' -> raise_type_error2 ast x x' y y' "'int' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (56-57): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (57-61): 
      left
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-66): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (67-85): 
       and a 'prop-set' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (85-86): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (86-91): 
      right
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (91-92): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (92-96): 
      hand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (96-97): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (97-99): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 522
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 523
  (* We consider 'bigand' as the universal quantification; it could be translated as

  LINE CONTAINS 30 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (2-3): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (3-4): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-7): 
      We
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-16): 
      consider
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-18): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (18-24): 
      bigand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-28): 
      as
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-32): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-42): 
      universal
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-57): 
      quantification
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
      ;
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-61): 
      it
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-67): 
      could
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-70): 
      be
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (70-71): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (71-81): 
      translated
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (81-82): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (82-84): 
      as
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,56] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 524
         for all elements i of E, p(i) is true

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-9): 
               
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-12): 
      for
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-16): 
      all
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-25): 
      elements
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-27): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-30): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      E
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-35): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-37): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (38-47): 
       is true
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 525
     As such, whenever 'bigand' returns nothing (when condition always false or empty

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-48): 
           As such, whenever 'bigand' returns nothing 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-53): 
      when
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-63): 
      condition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (64-70): 
      always
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (70-71): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (71-76): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-79): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (80-85): 
      empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,57] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 526
     sets), we return Top. This means that an empty bigand satisfies all the p($i) *)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-9): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (10-78): 
      , we return Top. This means that an empty bigand satisfies all the p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (78-79): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (79-81): 
      $i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (81-82): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (82-86): 
       *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 527
  | Bigand (vars,sets,when_optional,body) ->

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-11): 
        | Bigand 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-16): 
      vars
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-21): 
      sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-35): 
      when_optional
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-40): 
      body
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (41-45): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 528
    let when_cond = match when_optional with Some x -> x | None -> Bool true in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-80): 
          let when_cond = match when_optional with Some x -> x | None -> Bool true in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,20] BeginEndRule "meta.function.ts", entered @-1
      * [38,21] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,22] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 529
    begin check_nb_vars_same_as_nb_sets ast vars sets;

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-53): 
          begin check_nb_vars_same_as_nb_sets ast vars sets
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (53-55): 
      ;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 530
      match vars,sets with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-22): 
            match vars,sets 
      * source.ts
    => TOKEN (22-26): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 531
      | [],[] | _,[] | [],_ -> failwith "shouln't happen: non-variable in big construct"

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
       
      * source.ts
    => TOKEN (8-9): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (9-10): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (10-11): 
      ,
      * source.ts
    => TOKEN (11-12): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (12-13): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-15): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (15-18): 
       _,
      * source.ts
    => TOKEN (18-19): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-20): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (20-21): 
       
      * source.ts
    => TOKEN (21-22): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (22-23): 
       
      * source.ts
    => TOKEN (23-24): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (24-25): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (25-28): 
      ,_ 
      * source.ts
    => TOKEN (28-29): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (29-30): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (30-40): 
       failwith 
      * source.ts
    => TOKEN (40-41): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (41-87): 
      shouln't happen: non-variable in big construct
      * source.ts
      * string.double.ts
    => TOKEN (87-88): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 532
      | [Loc (Var (name,_),loc)],[set] -> (* we don't need the indices because bigand's vars are 'simple' *)

  LINE CONTAINS 34 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
       
      * source.ts
    => TOKEN (8-9): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (9-13): 
      Loc 
      * source.ts
      * meta.array.literal.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (14-18): 
      Var 
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (19-25): 
      name,_
      * source.ts
      * meta.array.literal.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (26-30): 
      ,loc
      * source.ts
      * meta.array.literal.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (32-33): 
      ,
      * source.ts
    => TOKEN (33-34): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (34-37): 
      set
      * source.ts
      * meta.array.literal.ts
    => TOKEN (37-38): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (38-39): 
       
      * source.ts
    => TOKEN (39-40): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (40-41): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (41-42): 
       
      * source.ts
    => TOKEN (42-43): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (43-44): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (44-51): 
       we don
      * source.ts
    => TOKEN (51-52): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (52-85): 
      t need the indices because bigand
      * source.ts
      * string.single.ts
    => TOKEN (85-86): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (86-97): 
      s vars are 
      * source.ts
    => TOKEN (97-98): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (98-104): 
      simple
      * source.ts
      * string.single.ts
    => TOKEN (104-105): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (105-106): 
       
      * source.ts
    => TOKEN (106-107): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (107-108): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 533
        let rec process_list_set env (set_list:Ast.t list) =

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-15): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (16-37): 
      process_list_set env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (37-38): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (38-57): 
      set_list:Ast.t list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (57-58): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (59-60): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 534
          match set_list with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-25): 
                match set_list 
      * source.ts
    => TOKEN (25-29): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 535
          | []   -> Top (*  what if bigand in a or? We give a warning (see below) *)

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-13): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (13-14): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (14-17): 
         
      * source.ts
    => TOKEN (17-18): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (18-19): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (19-24): 
       Top 
      * source.ts
    => TOKEN (24-25): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (25-26): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (26-33): 
        what 
      * source.ts
    => TOKEN (33-35): 
      if
      * source.ts
      * keyword.control.ts
    => TOKEN (35-43): 
       bigand 
      * source.ts
    => TOKEN (43-45): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (45-70): 
       a or? We give a warning 
      * source.ts
    => TOKEN (70-71): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (71-80): 
      see below
      * source.ts
    => TOKEN (80-81): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (81-82): 
       
      * source.ts
    => TOKEN (82-83): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (83-84): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 536
          | x::xs ->

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-18): 
       x::xs 
      * source.ts
    => TOKEN (18-19): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 537
            let env = (name,(x,loc))::env in

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-15): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (16-19): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (19-21): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (23-28): 
      name,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (29-34): 
      x,loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (36-37): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (37-38): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (38-41): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (42-44): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 538
            match ast_to_bool env when_cond with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-44): 
                  match ast_to_bool env when_cond 
      * source.ts
    => TOKEN (44-48): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 539
            | true when xs != [] -> And (eval_ast_formula_env env body, process_list_set env xs)

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-18): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (18-27): 
       when xs 
      * source.ts
    => TOKEN (27-29): 
      !=
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (29-30): 
       
      * source.ts
    => TOKEN (30-31): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (31-32): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (32-33): 
       
      * source.ts
    => TOKEN (33-34): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (34-35): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (35-40): 
       And 
      * source.ts
    => TOKEN (40-41): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (41-95): 
      eval_ast_formula_env env body, process_list_set env xs
      * source.ts
    => TOKEN (95-96): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 540
            | true  -> eval_ast_formula_env env body

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-18): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (18-20): 
        
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (22-53): 
       eval_ast_formula_env env body
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 541
            | false -> process_list_set env xs

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-19): 
      false
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (19-20): 
       
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (22-47): 
       process_list_set env xs
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 542
        in

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
    => TOKEN (8-10): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 543
        let list_ast_set = set_to_ast_list env set in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-24): 
      list_ast_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (24-26): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (26-51): 
       set_to_ast_list env set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (51-53): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 544
        let evaluated_ast = process_list_set env list_ast_set in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-25): 
      evaluated_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (25-27): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-62): 
       process_list_set env list_ast_set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (62-64): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 545
        rm_top_bot evaluated_ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
              rm_top_bot evaluated_ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 546
      | x::xs,y::ys ->

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-20): 
       x::xs,y::ys 
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 547
        eval_ast_formula (Bigand ([x],[y],None,(Bigand (xs,ys,when_optional,body))))

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-25): 
              eval_ast_formula 
      * source.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (26-33): 
      Bigand 
      * source.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (34-35): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.array.literal.ts
    => TOKEN (36-37): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (37-38): 
      ,
      * source.ts
    => TOKEN (38-39): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (39-40): 
      y
      * source.ts
      * meta.array.literal.ts
    => TOKEN (40-41): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (41-47): 
      ,None,
      * source.ts
    => TOKEN (47-48): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (48-55): 
      Bigand 
      * source.ts
    => TOKEN (55-56): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (56-80): 
      xs,ys,when_optional,body
      * source.ts
    => TOKEN (80-81): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (81-82): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (82-83): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (83-84): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 548
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 549
  (* bigor returns 'Bot' when it returns nothing. It can be interpreted as the

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (3-4): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (4-19): 
       bigor returns 
      * source.ts
    => TOKEN (19-20): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (20-23): 
      Bot
      * source.ts
      * string.single.ts
    => TOKEN (23-24): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (24-72): 
       when it returns nothing. It can be interpreted 
      * source.ts
    => TOKEN (72-74): 
      as
      * source.ts
      * keyword.others.ts
    => TOKEN (74-79): 
       the
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,58] BeginEndRule "null", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 550
     existential quantificator

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-31): 
           existential quantificator
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,58] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 551
         there exists some i of E so that p(i) is true

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-29): 
               there exists some i 
      * source.ts
    => TOKEN (29-31): 
      of
      * source.ts
      * keyword.others.ts
    => TOKEN (31-43): 
       E so that p
      * source.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (44-45): 
      i
      * source.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (46-47): 
       
      * source.ts
    => TOKEN (47-49): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (49-50): 
       
      * source.ts
    => TOKEN (50-54): 
      true
      * source.ts
      * constant.language.boolean.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,58] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 552
     When it is applied an empty E, it means that there exists no elements that

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-13): 
           When it 
      * source.ts
    => TOKEN (13-15): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (15-80): 
       applied an empty E, it means that there exists no elements that
      * source.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,58] BeginEndRule "null", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 553
     satisfy p(i), so we return Bot. *)

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-14): 
           satisfy p
      * source.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (15-16): 
      i
      * source.ts
    => TOKEN (16-17): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (17-25): 
      , so we 
      * source.ts
    => TOKEN (25-31): 
      return
      * source.ts
      * keyword.control.ts
    => TOKEN (31-37): 
       Bot. 
      * source.ts
    => TOKEN (37-38): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (38-39): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 554
  | Bigor (vars,sets,when_optional,body) ->

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-10): 
       Bigor 
      * source.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (11-39): 
      vars,sets,when_optional,body
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-41): 
       
      * source.ts
    => TOKEN (41-42): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (42-43): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 555
    let when_cond = match when_optional with Some x -> x | None -> Bool true

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-17): 
      when_cond
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (17-19): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (19-40): 
       match when_optional 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (40-44): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts
    => TOKEN (44-52): 
       Some x 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (52-53): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (53-54): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (54-57): 
       x 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (57-58): 
      |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (58-64): 
       None 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (64-65): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (65-66): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (66-72): 
       Bool 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (72-76): 
      true
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * constant.language.boolean.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 556
    in

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-6): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 557
    begin check_nb_vars_same_as_nb_sets ast vars sets;

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-55): 
          begin check_nb_vars_same_as_nb_sets ast vars sets;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 558
      match vars,sets with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-22): 
            match vars,sets 
      * source.ts
    => TOKEN (22-26): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 559
      | [],[] | _,[] | [],_ -> failwith "shouln't happen: non-variable in big construct"

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
       
      * source.ts
    => TOKEN (8-9): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (9-10): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (10-11): 
      ,
      * source.ts
    => TOKEN (11-12): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (12-13): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-15): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (15-18): 
       _,
      * source.ts
    => TOKEN (18-19): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-20): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (20-21): 
       
      * source.ts
    => TOKEN (21-22): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (22-23): 
       
      * source.ts
    => TOKEN (23-24): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (24-25): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (25-28): 
      ,_ 
      * source.ts
    => TOKEN (28-29): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (29-30): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (30-40): 
       failwith 
      * source.ts
    => TOKEN (40-41): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (41-87): 
      shouln't happen: non-variable in big construct
      * source.ts
      * string.double.ts
    => TOKEN (87-88): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 560
      | [Loc (Var (name,_),loc)],[set] ->

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
       
      * source.ts
    => TOKEN (8-9): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (9-13): 
      Loc 
      * source.ts
      * meta.array.literal.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (14-18): 
      Var 
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (19-25): 
      name,_
      * source.ts
      * meta.array.literal.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (26-30): 
      ,loc
      * source.ts
      * meta.array.literal.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.array.literal.ts
      * meta.brace.paren.ts
    => TOKEN (31-32): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (32-33): 
      ,
      * source.ts
    => TOKEN (33-34): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (34-37): 
      set
      * source.ts
      * meta.array.literal.ts
    => TOKEN (37-38): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (38-39): 
       
      * source.ts
    => TOKEN (39-40): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (40-41): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 561
        let rec process_list_set env (set_list:Ast.t list) =

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-15): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (16-37): 
      process_list_set env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (37-38): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (38-57): 
      set_list:Ast.t list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (57-58): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (59-60): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 562
          match set_list with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-25): 
                match set_list 
      * source.ts
    => TOKEN (25-29): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 563
          | []    -> Bottom

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-13): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (13-14): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (14-18): 
          
      * source.ts
    => TOKEN (18-19): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (20-28): 
       Bottom
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 564
          | x::xs ->

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-18): 
       x::xs 
      * source.ts
    => TOKEN (18-19): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (19-20): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 565
            let env = (name,(x,loc))::env in

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-15): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (15-16): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (16-19): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (19-21): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (23-28): 
      name,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (29-34): 
      x,loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (34-35): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (36-37): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (37-38): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (38-41): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
    => TOKEN (42-44): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.type.annotation.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 566
            match ast_to_bool env when_cond with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-44): 
                  match ast_to_bool env when_cond 
      * source.ts
    => TOKEN (44-48): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 567
            | true when xs != [] -> Or (eval_ast_formula_env env body, process_list_set env xs)

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-18): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (18-27): 
       when xs 
      * source.ts
    => TOKEN (27-29): 
      !=
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (29-30): 
       
      * source.ts
    => TOKEN (30-31): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (31-32): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (32-33): 
       
      * source.ts
    => TOKEN (33-34): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (34-35): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (35-39): 
       Or 
      * source.ts
    => TOKEN (39-40): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-94): 
      eval_ast_formula_env env body, process_list_set env xs
      * source.ts
    => TOKEN (94-95): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 568
            | true  -> eval_ast_formula_env env body

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-18): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (18-20): 
        
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (22-53): 
       eval_ast_formula_env env body
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 569
            | false -> process_list_set env xs

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-12): 
                  
      * source.ts
    => TOKEN (12-13): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
       
      * source.ts
    => TOKEN (14-19): 
      false
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (19-20): 
       
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (22-47): 
       process_list_set env xs
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 570
        in

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
    => TOKEN (8-10): 
      in
      * source.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 571
        let list_ast_set = set_to_ast_list env set in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-24): 
      list_ast_set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (24-26): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (26-51): 
       set_to_ast_list env set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (51-53): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 572
        let evaluated_ast = process_list_set env list_ast_set in

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-11): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (12-25): 
      evaluated_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (25-27): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-62): 
       process_list_set env list_ast_set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (62-64): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.others.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 573
        rm_top_bot evaluated_ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-33): 
              rm_top_bot evaluated_ast
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 574
      | x::xs,y::ys ->

  LINE CONTAINS 5 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-20): 
       x::xs,y::ys 
      * source.ts
    => TOKEN (20-21): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-22): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 575
        eval_ast_formula (Bigor ([x],[y],None,(Bigor (xs,ys,when_optional,body))))

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-25): 
              eval_ast_formula 
      * source.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (26-32): 
      Bigor 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-34): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (34-35): 
      x
      * source.ts
      * meta.array.literal.ts
    => TOKEN (35-36): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (36-37): 
      ,
      * source.ts
    => TOKEN (37-38): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (38-39): 
      y
      * source.ts
      * meta.array.literal.ts
    => TOKEN (39-40): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (40-46): 
      ,None,
      * source.ts
    => TOKEN (46-47): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (47-53): 
      Bigor 
      * source.ts
    => TOKEN (53-54): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (54-78): 
      xs,ys,when_optional,body
      * source.ts
    => TOKEN (78-79): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (79-80): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (80-81): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (81-82): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 576
    end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-8): 
          end
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 577
  | If (c,y,z) ->

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-7): 
       If 
      * source.ts
    => TOKEN (7-8): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (8-13): 
      c,y,z
      * source.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-15): 
       
      * source.ts
    => TOKEN (15-16): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (16-17): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 578
    let test = match eval_ast c with Bool c -> c | c' -> raise_type_error ast c c' "boolean"

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-12): 
      test
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (12-14): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (14-32): 
       match eval_ast c 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (32-36): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts
    => TOKEN (36-44): 
       Bool c 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (44-45): 
      -
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (45-46): 
      >
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (46-49): 
       c 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (49-50): 
      |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (50-52): 
       c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (52-53): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.single.ts
    => TOKEN (53-81): 
       -> raise_type_error ast c c
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.single.ts
    => TOKEN (81-82): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.single.ts
    => TOKEN (82-83): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (83-84): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.double.ts
    => TOKEN (84-91): 
      boolean
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.double.ts
    => TOKEN (91-92): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 579
    in if test then eval_ast_formula y else eval_ast_formula z

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-6): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (6-7): 
       
      * source.ts
    => TOKEN (7-9): 
      if
      * source.ts
      * keyword.control.ts
    => TOKEN (9-39): 
       test then eval_ast_formula y 
      * source.ts
    => TOKEN (39-43): 
      else
      * source.ts
      * keyword.control.ts
    => TOKEN (43-63): 
       eval_ast_formula z
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 580
  | Let (Loc (Var (p,i),loc),content,formula) ->

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-8): 
       Let 
      * source.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-13): 
      Loc 
      * source.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-18): 
      Var 
      * source.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (19-22): 
      p,i
      * source.ts
    => TOKEN (22-23): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (23-27): 
      ,loc
      * source.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (28-44): 
      ,content,formula
      * source.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (45-46): 
       
      * source.ts
    => TOKEN (46-47): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (47-48): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 581
    let name = (expand_var_name env (p,i)) and desc = (eval_ast content,loc)

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-12): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (12-14): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (15-16): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (16-36): 
      expand_var_name env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (37-40): 
      p,i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (42-52): 
       and desc 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (52-53): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (54-55): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (55-75): 
      eval_ast content,loc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (75-76): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 582
    in eval_ast_formula_env ((name,desc)::env) formula

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-6): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (6-28): 
       eval_ast_formula_env 
      * source.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (29-30): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (30-39): 
      name,desc
      * source.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (40-45): 
      ::env
      * source.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (46-55): 
       formula
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 583
  | Paren x -> eval_ast_formula x

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-12): 
       Paren x 
      * source.ts
    => TOKEN (12-13): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-34): 
       eval_ast_formula x
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 584
  | Exists (p,f) -> let p = match eval_ast_formula p with

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-11): 
       Exists 
      * source.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-15): 
      p,f
      * source.ts
    => TOKEN (15-16): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (16-17): 
       
      * source.ts
    => TOKEN (17-18): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (18-19): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (20-23): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (24-25): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (25-27): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-53): 
       match eval_ast_formula p 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (53-57): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 585
    | Prop p -> Prop p

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-13): 
       Prop p 
      * source.ts
    => TOKEN (13-14): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (14-15): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (15-23): 
       Prop p
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 586
    | wrong -> raise_with_loc p ("'exists' only works on propositions. Instead, got a "

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-12): 
       wrong 
      * source.ts
    => TOKEN (12-13): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-32): 
       raise_with_loc p 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-34): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (34-86): 
      'exists' only works on propositions. Instead, got a 
      * source.ts
      * string.double.ts
    => TOKEN (86-87): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,59] BeginEndRule "null", entered @14
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 587
        ^"'"^string_of_ast_type wrong^"'.\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
    => TOKEN (8-9): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      '
      * source.ts
      * string.double.ts
    => TOKEN (11-12): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (12-13): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-37): 
      string_of_ast_type wrong
      * source.ts
    => TOKEN (37-38): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (38-39): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (39-41): 
      '.
      * source.ts
      * string.double.ts
    => TOKEN (41-43): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (43-44): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 588
    in Exists (p, eval_ast_formula f)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-6): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (6-14): 
       Exists 
      * source.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (15-36): 
      p, eval_ast_formula f
      * source.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 589
  | Forall (p,f) -> let p = match eval_ast_formula p with

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-11): 
       Forall 
      * source.ts
    => TOKEN (11-12): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (12-15): 
      p,f
      * source.ts
    => TOKEN (15-16): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (16-17): 
       
      * source.ts
    => TOKEN (17-18): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (18-19): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (20-23): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (24-25): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (25-27): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (27-53): 
       match eval_ast_formula p 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (53-57): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 590
    | Prop p -> Prop p

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-13): 
       Prop p 
      * source.ts
    => TOKEN (13-14): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (14-15): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (15-23): 
       Prop p
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 591
    | wrong -> raise_with_loc p ("'forall' only works on propositions. Instead, got a "

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-12): 
       wrong 
      * source.ts
    => TOKEN (12-13): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-32): 
       raise_with_loc p 
      * source.ts
    => TOKEN (32-33): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (33-34): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (34-86): 
      'forall' only works on propositions. Instead, got a 
      * source.ts
      * string.double.ts
    => TOKEN (86-87): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,60] BeginEndRule "null", entered @14
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 592
        ^"'"^string_of_ast_type wrong^"'.\n")

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
    => TOKEN (8-9): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (9-10): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (10-11): 
      '
      * source.ts
      * string.double.ts
    => TOKEN (11-12): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (12-13): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-37): 
      string_of_ast_type wrong
      * source.ts
    => TOKEN (37-38): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (38-39): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (39-41): 
      '.
      * source.ts
      * string.double.ts
    => TOKEN (41-43): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (43-44): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 593
    in Forall (p, eval_ast_formula f)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-6): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (6-14): 
       Forall 
      * source.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (15-36): 
      p, eval_ast_formula f
      * source.ts
    => TOKEN (36-37): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 594
  | For (Loc (Var (p,i),loc), content, Loc (formula,_)) ->

  LINE CONTAINS 20 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-8): 
       For 
      * source.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (9-13): 
      Loc 
      * source.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-18): 
      Var 
      * source.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (19-22): 
      p,i
      * source.ts
    => TOKEN (22-23): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (23-27): 
      ,loc
      * source.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (28-43): 
      , content, Loc 
      * source.ts
    => TOKEN (43-44): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (44-53): 
      formula,_
      * source.ts
    => TOKEN (53-54): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (54-55): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (55-56): 
       
      * source.ts
    => TOKEN (56-57): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (57-58): 
      >
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 595
    let name = (expand_var_name env (p,i)) in begin

  LINE CONTAINS 15 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
      * meta.var.expr.ts
    => TOKEN (4-7): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (8-12): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (12-14): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (15-16): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (16-36): 
      expand_var_name env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (37-40): 
      p,i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (43-45): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.others.ts
    => TOKEN (45-51): 
       begin
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 596
    match formula, eval_ast content with

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-36): 
          match formula, eval_ast content 
      * source.ts
    => TOKEN (36-40): 
      with
      * source.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 597
    | Exists (x,f), Set s -> AstSet.fold (fun content acc -> Exists (eval_ast_formula_env ((name,(content,loc))::env) x, acc)) s (eval_ast_formula f)

  LINE CONTAINS 33 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-13): 
       Exists 
      * source.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-17): 
      x,f
      * source.ts
    => TOKEN (17-18): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (18-26): 
      , Set s 
      * source.ts
    => TOKEN (26-27): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (27-28): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (28-41): 
       AstSet.fold 
      * source.ts
    => TOKEN (41-42): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (42-58): 
      fun content acc 
      * source.ts
    => TOKEN (58-59): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (59-60): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (60-68): 
       Exists 
      * source.ts
    => TOKEN (68-69): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (69-90): 
      eval_ast_formula_env 
      * source.ts
    => TOKEN (90-91): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (91-92): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (92-97): 
      name,
      * source.ts
    => TOKEN (97-98): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (98-109): 
      content,loc
      * source.ts
    => TOKEN (109-110): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (110-111): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (111-116): 
      ::env
      * source.ts
    => TOKEN (116-117): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (117-124): 
       x, acc
      * source.ts
    => TOKEN (124-125): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (125-126): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (126-129): 
       s 
      * source.ts
    => TOKEN (129-130): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (130-148): 
      eval_ast_formula f
      * source.ts
    => TOKEN (148-149): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 598
    | Forall (x,f), Set s -> AstSet.fold (fun content acc -> Forall (eval_ast_formula_env ((name,(content,loc))::env) x, acc)) s (eval_ast_formula f)

  LINE CONTAINS 33 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-13): 
       Forall 
      * source.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-17): 
      x,f
      * source.ts
    => TOKEN (17-18): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (18-26): 
      , Set s 
      * source.ts
    => TOKEN (26-27): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (27-28): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (28-41): 
       AstSet.fold 
      * source.ts
    => TOKEN (41-42): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (42-58): 
      fun content acc 
      * source.ts
    => TOKEN (58-59): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (59-60): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (60-68): 
       Forall 
      * source.ts
    => TOKEN (68-69): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (69-90): 
      eval_ast_formula_env 
      * source.ts
    => TOKEN (90-91): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (91-92): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (92-97): 
      name,
      * source.ts
    => TOKEN (97-98): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (98-109): 
      content,loc
      * source.ts
    => TOKEN (109-110): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (110-111): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (111-116): 
      ::env
      * source.ts
    => TOKEN (116-117): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (117-124): 
       x, acc
      * source.ts
    => TOKEN (124-125): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (125-126): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (126-129): 
       s 
      * source.ts
    => TOKEN (129-130): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (130-148): 
      eval_ast_formula f
      * source.ts
    => TOKEN (148-149): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 599
    | _,content' -> raise_type_error ast content content' " 'prop-set'"

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-4): 
          
      * source.ts
    => TOKEN (4-5): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (5-15): 
       _,content
      * source.ts
    => TOKEN (15-16): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (16-56): 
       -> raise_type_error ast content content
      * source.ts
      * string.single.ts
    => TOKEN (56-57): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (57-58): 
       
      * source.ts
    => TOKEN (58-59): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (59-70): 
       'prop-set'
      * source.ts
      * string.double.ts
    => TOKEN (70-71): 
      "
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 600
  end

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-6): 
        end
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 601
  | NewlineBefore f | NewlineAfter f -> eval_ast_formula f

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-20): 
       NewlineBefore f 
      * source.ts
    => TOKEN (20-21): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (21-37): 
       NewlineAfter f 
      * source.ts
    => TOKEN (37-38): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (38-39): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (39-59): 
       eval_ast_formula f
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 602
  | e -> raise_with_loc ast ("this expression is not a formula: " ^ string_of_ast e ^"\n")

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-6): 
       e 
      * source.ts
    => TOKEN (6-7): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (7-8): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (8-28): 
       raise_with_loc ast 
      * source.ts
    => TOKEN (28-29): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (29-30): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (30-64): 
      this expression is not a formula: 
      * source.ts
      * string.double.ts
    => TOKEN (64-65): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (65-66): 
       
      * source.ts
    => TOKEN (66-67): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (67-84): 
       string_of_ast e 
      * source.ts
    => TOKEN (84-85): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (85-86): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (86-88): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (88-89): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (89-90): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 603


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 604
and exact_str lst =

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-18): 
      and exact_str lst 
      * source.ts
    => TOKEN (18-19): 
      =
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 605
  let rec go = function

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (6-9): 
      rec
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (10-13): 
      go 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (13-14): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.operator.comparison.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (15-23): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * storage.type.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @14
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @5
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @0
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 606
    | [],[]       -> Top

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-25): 
          | [],[]       -> Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 607
    | t::ts,[]    -> And (     t,         go (ts,[]))

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-25): 
          | t::ts,[]    -> And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-31): 
           
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-42): 
               
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-44): 
      go
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (46-48): 
      ts
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-51): 
      ,[]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (52-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 608
    | [],f::fs    -> And (        Not f,  go ([],fs))

  LINE CONTAINS 14 TOKENS:
    => TOKEN (0-25): 
          | [],f::fs    -> And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-34): 
              
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-37): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-39): 
      f
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-42): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-44): 
      go
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-49): 
      ([],
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-51): 
      fs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (52-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 609
    | t::ts,f::fs -> And (And (t, Not f), go (ts,fs))

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-25): 
          | t::ts,f::fs -> And 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-29): 
      And
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-32): 
      t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (33-34): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (34-37): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-39): 
      f
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (40-45): 
      , go 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (45-46): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (46-48): 
      ts
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-51): 
      fs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (52-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 610
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 611
  match lst with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-17): 
        match lst with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 612
  | []    -> Bottom

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-20): 
        | []    -> Bottom
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 613
  | x::xs -> Or (go x, exact_str xs)

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-16): 
        | x::xs -> Or 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-19): 
      go
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-32): 
      exact_str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      xs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 614


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 615
and atleast_str lst =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-22): 
      and atleast_str lst =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 616
  List.fold_left (fun acc str -> Or (acc, formula_of_string_list str)) Bottom lst

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-17): 
        List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-21): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-25): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-32): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-35): 
      Or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-37): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-40): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-64): 
      formula_of_string_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (65-68): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (69-82): 
      ) Bottom lst
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 617


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 618
and atmost_str lst =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-21): 
      and atmost_str lst =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 619
  List.fold_left (fun acc str ->

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-17): 
        List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-21): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-25): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-33): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,64] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 620
      Or (acc, List.fold_left (fun acc' str' ->

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-8): 
      Or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (8-9): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (9-10): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (10-13): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-19): 
      List
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-29): 
      fold_left
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-34): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-38): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-43): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (43-48): 
      ' ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,64] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 621
          And (acc', Not str')) Top str)) Bottom lst

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-13): 
      And
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-18): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-20): 
      ',
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-24): 
      Not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-28): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-53): 
      ) Top str)) Bottom lst
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 622


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 623
and formula_of_string_list =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-29): 
      and formula_of_string_list =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 624
  List.fold_left (fun acc str -> And (acc, str)) Top

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-17): 
        List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-21): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-25): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-32): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-36): 
      And
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-38): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-41): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-46): 
      str
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (47-53): 
      ) Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 625


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 626
and and_of_term_list =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
      and and_of_term_list =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 627
  List.fold_left (fun acc t -> And (acc, t)) Top

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-17): 
        List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-18): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-21): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-25): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-27): 
      t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-30): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-34): 
      And
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-39): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-42): 
      t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (43-49): 
      ) Top
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 628


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 629
(* [expand_prop] will expand a proposition containing a set as index, e.g.,

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (1-4): 
      * [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-15): 
      expand_prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-21): 
      will
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-28): 
      expand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-42): 
      proposition
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-53): 
      containing
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-55): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-59): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-62): 
      as
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-68): 
      index
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-71): 
      e
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (72-73): 
      g
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-76): 
      .,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,65] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 630
   time([1,2],[a,b]) will become [time(1,a),time(1,b)...time(b,2)]. This is useful when

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (3-7): 
      time
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (7-15): 
      ([1,2],[
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (15-16): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (20-38): 
       will become [time
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (38-39): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (39-41): 
      1,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-42): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (43-48): 
      ,time
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (48-49): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (49-51): 
      1,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (51-52): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (53-60): 
      ...time
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (60-61): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (61-62): 
      b
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-64): 
      ,2
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (65-88): 
      ]. This is useful when
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 631
   generating sets. *)

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
         generating sets. *)
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 632
and expand_prop_with_set env name indices_optional =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-53): 
      and expand_prop_with_set env name indices_optional =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 633
  let rec eval_indices env (l:Ast.t list) :Ast.t list = match l with

  LINE CONTAINS 18 TOKENS:
    => TOKEN (0-27): 
        let rec eval_indices env 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (27-28): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-29): 
      l
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (30-35): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (36-40): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (41-43): 
       :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (43-48): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (49-53): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (53-56): 
       = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (56-61): 
      match
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (62-63): 
      l
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (63-64): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (64-68): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 634
    | [] -> []

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-15): 
          | [] -> []
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 635
    | x::xs -> (eval_ast env x)::(eval_indices env xs)

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-15): 
          | x::xs -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (15-16): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (16-24): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-28): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-30): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-32): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (32-33): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (34-46): 
      eval_indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (47-50): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
    => TOKEN (51-53): 
      xs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts
      * meta.type.name.ts
    => TOKEN (53-54): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.paren.cover.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 636
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 637
  let rec has_nonempty_set = function

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-29): 
        let rec has_nonempty_set = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (29-37): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * storage.type.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 638
    | []         -> false

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-26): 
          | []         -> false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 639
    | (Set s)::_ when AstSet.is_empty s -> false

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-6): 
          | 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-10): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-12): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (14-15): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (15-16): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (17-21): 
      when
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (22-37): 
      AstSet.is_empty
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (38-39): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (39-43): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (43-48): 
      false
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 640
    | (Set _)::_ -> true

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-6): 
          | 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (6-7): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (7-10): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-12): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (13-14): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (14-15): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (15-16): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (16-20): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (20-24): 
      true
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 641
    | _::next    -> has_nonempty_set next

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-42): 
          | _::next    -> has_nonempty_set next
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 642
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 643
  let indices, generated_props = match indices_optional with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-61): 
        let indices, generated_props = match indices_optional with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 644
    | None   -> [], [UnexpProp (name,None)]

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-31): 
          | None   -> [], [UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (32-36): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-41): 
      None
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (42-44): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 645
    | Some x -> let indices = eval_indices env x in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-52): 
          | Some x -> let indices = eval_indices env x in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 646
            indices, expand_prop_with_set' [UnexpProp (name,None)] indices env

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-54): 
                  indices, expand_prop_with_set' [UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (54-55): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (55-59): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (60-64): 
      None
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (65-79): 
      ] indices env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 647
  in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-5): 
        in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 648
  let eval_unexpprop acc cur = match cur with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-46): 
        let eval_unexpprop acc cur = match cur with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 649
    | UnexpProp (p,i) -> (Prop (expand_var_name env (p,i)))::acc | _->failwith "shouldnt happen"

  LINE CONTAINS 35 TOKENS:
    => TOKEN (0-16): 
          | UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (16-17): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (17-18): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (19-20): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-25): 
       -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (25-26): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-30): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-47): 
      expand_var_name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-48): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (48-51): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-53): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (53-54): 
      p
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (55-56): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (57-59): 
      ))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (59-60): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (60-61): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (61-64): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (64-65): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (65-66): 
      |
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * keyword.operator.type.ts
    => TOKEN (66-67): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (67-68): 
      _
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (68-70): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (70-78): 
      failwith
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (78-80): 
       "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (80-88): 
      shouldnt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (88-89): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (89-95): 
      happen
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (95-96): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 650
  in let props_evaluated = List.fold_left eval_unexpprop [] generated_props in

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-79): 
        in let props_evaluated = List.fold_left eval_unexpprop [] generated_props in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 651
  if (let x = has_nonempty_set indices in x) then Set (AstSet.of_list props_evaluated)

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-5): 
        if 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (5-6): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (6-9): 
      let
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-11): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (13-39): 
       has_nonempty_set indices 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (39-41): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.others.ts
    => TOKEN (41-43): 
       x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-44): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (44-54): 
       then Set 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (54-55): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (55-61): 
      AstSet
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-69): 
      of_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-85): 
      props_evaluated
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 652
  else List.nth props_evaluated 0

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-34): 
        else List.nth props_evaluated 0
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 653


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 654
and expand_prop_with_set' proplist indices env =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-49): 
      and expand_prop_with_set' proplist indices env =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 655
  match indices with (* at this point, indice is either a Prop or a Set *)

  LINE CONTAINS 29 TOKENS:
    => TOKEN (0-21): 
        match indices with 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (21-22): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (22-23): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-26): 
      at
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-31): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-37): 
      point
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-45): 
      indice
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-48): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-55): 
      either
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-57): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-62): 
      Prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-65): 
      or
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (65-66): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (66-67): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-71): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-73): 
      *
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (73-74): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 656
  | [] -> proplist

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-19): 
        | [] -> proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 657
  | i::next ->

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-15): 
        | i::next ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 658
    match i with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-17): 
          match i with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 659
    | Set s when AstSet.is_empty s -> expand_prop_with_set' proplist next env

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-78): 
          | Set s when AstSet.is_empty s -> expand_prop_with_set' proplist next env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 660
    | Set s -> let new_proplist = (expand_proplist proplist (set_to_ast_list env (Set s))) in

  LINE CONTAINS 17 TOKENS:
    => TOKEN (0-34): 
          | Set s -> let new_proplist = 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (35-50): 
      expand_proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-59): 
      proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-61): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (61-76): 
      set_to_ast_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (76-77): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (77-80): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-82): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (82-85): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (85-86): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (86-87): 
      s
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (87-88): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (88-94): 
      )) in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 661
        expand_prop_with_set' new_proplist next env

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-52): 
              expand_prop_with_set' new_proplist next env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 662
    | x -> expand_prop_with_set' (expand_proplist proplist [x]) next env

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-33): 
          | x -> expand_prop_with_set' 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (34-49): 
      expand_proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-58): 
      proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-60): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (60-61): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-63): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (63-73): 
       next env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 663
and expand_proplist proplist ind = match proplist with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-55): 
      and expand_proplist proplist ind = match proplist with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 664
  | [] -> []

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-13): 
        | [] -> []
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 665
  | x::xs -> (expand_prop x ind) @ (expand_proplist xs ind)

  LINE CONTAINS 16 TOKENS:
    => TOKEN (0-13): 
        | x::xs -> 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-25): 
      expand_prop
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-27): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      ind
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (32-35): 
       @ 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (35-36): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (36-51): 
      expand_proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-54): 
      xs
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-58): 
      ind
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 666
and expand_prop prop ind = match prop with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-43): 
      and expand_prop prop ind = match prop with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 667
  | UnexpProp (name, None) -> List.fold_left (fun acc i -> (UnexpProp (name,Some ([i])))::acc) [] ind

  LINE CONTAINS 36 TOKENS:
    => TOKEN (0-14): 
        | UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-19): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-25): 
      None
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (26-45): 
       -> List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (45-46): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (46-49): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-55): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-60): 
      -> (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (60-69): 
      UnexpProp
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-71): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (71-75): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (75-76): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (76-80): 
      Some
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (80-81): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (81-83): 
      ([
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (83-84): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (85-86): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (86-88): 
      ))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (88-89): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (89-90): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (90-93): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (93-95): 
      ) 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (95-96): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.tuple.ts
      * meta.brace.square.ts
    => TOKEN (96-97): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.tuple.ts
      * meta.brace.square.ts
    => TOKEN (97-98): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (98-101): 
      ind
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 668
  | UnexpProp (name, Some cur) -> List.fold_left (fun acc i -> (UnexpProp (name,Some (cur @ [i])))::acc) [] ind

  LINE CONTAINS 41 TOKENS:
    => TOKEN (0-14): 
        | UnexpProp 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-19): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-25): 
      Some
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      cur
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (30-49): 
       -> List.fold_left 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (49-50): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (50-53): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-57): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (57-58): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (58-59): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-64): 
      -> (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (64-73): 
      UnexpProp
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-75): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (75-79): 
      name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-80): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (80-84): 
      Some
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (84-85): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (85-86): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (86-89): 
      cur
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (89-90): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (90-93): 
      @ [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (93-94): 
      i
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (94-95): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (95-96): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (96-98): 
      ))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (98-99): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (99-100): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (100-103): 
      acc
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (103-105): 
      ) 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (105-106): 
      [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.tuple.ts
      * meta.brace.square.ts
    => TOKEN (106-107): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.tuple.ts
      * meta.brace.square.ts
    => TOKEN (107-108): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (108-111): 
      ind
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 669
  | x -> failwith ("[shouldnt happen] proplist contains smth that is not UnexpProp: "^string_of_ast_type x)

  LINE CONTAINS 26 TOKENS:
    => TOKEN (0-18): 
        | x -> failwith 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (18-19): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-21): 
      "[
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-29): 
      shouldnt
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-36): 
      happen
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-46): 
      proplist
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-55): 
      contains
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-60): 
      smth
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (61-65): 
      that
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (65-66): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (66-68): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-72): 
      not
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (72-73): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (73-82): 
      UnexpProp
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (82-83): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (83-84): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (84-85): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (85-106): 
      ^string_of_ast_type x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts
    => TOKEN (106-107): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,66] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 670
and expand_var_name (env:env) (prefix,indices:string * Ast.t list option) =

  LINE CONTAINS 24 TOKENS:
    => TOKEN (0-3): 
      and
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (3-4): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (4-19): 
      expand_var_name
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (21-24): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (25-28): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (28-29): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (31-37): 
      prefix
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (38-45): 
      indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (45-46): 
      :
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (46-52): 
      string
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.primitive.ts
      * support.type.ts
    => TOKEN (52-55): 
       * 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (55-60): 
      Ast.t
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (60-61): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (61-65): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (65-66): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (66-72): 
      option
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (72-73): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (73-76): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 671
  match (prefix,indices) with

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-8): 
        match 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (8-9): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (9-15): 
      prefix
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-23): 
      indices
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-30): 
       with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 672
  | (x,None)   -> x

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-4): 
        | 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (5-6): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (6-7): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-11): 
      None
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (12-20): 
         -> x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 673
  | (x,Some y) ->

  LINE CONTAINS 9 TOKENS:
    => TOKEN (0-4): 
        | 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (4-5): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (5-6): 
      x
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (6-7): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-11): 
      Some
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-13): 
      y
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-18): 
       ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 674
    x ^ "("

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-9): 
          x ^ "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (9-10): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (10-12): 
      "
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,67] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 675
    ^ (string_of_ast_list "," (List.map (fun e -> eval_ast env e) y))

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-7): 
          ^ (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-25): 
      string_of_ast_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-31): 
      "," (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (31-35): 
      List
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-39): 
      map
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (39-40): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (40-41): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (41-44): 
      fun
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-46): 
      e
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-49): 
      ->
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-58): 
      eval_ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-62): 
      env
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-64): 
      e
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (64-65): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (65-70): 
       y))
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 676
    ^ ")"

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-10): 
          ^ ")"
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 677


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 678
(* [set_to_ast_list] evaluates one element  of the list of things after

  LINE CONTAINS 22 TOKENS:
    => TOKEN (0-1): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (1-4): 
      * [
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-19): 
      set_to_ast_list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ]
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-30): 
      evaluates
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-34): 
      one
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-42): 
      element
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-44): 
        
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (44-46): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-50): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (50-51): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (51-55): 
      list
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (55-56): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (56-58): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (58-59): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (59-65): 
      things
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (65-66): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (66-71): 
      after
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,68] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 679
   the 'in' of bigand/bigor.

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (3-6): 
      the
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (6-7): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (7-8): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-10): 
      in
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
      '
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-14): 
      of
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-21): 
      bigand
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      /
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-27): 
      bigor
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-29): 
      .
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [78,68] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 680
   If this element is a set, it turns this Set (.) into a list of Int,

  LINE CONTAINS 25 TOKENS:
    => TOKEN (0-3): 
         
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (3-5): 
      If
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (6-10): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-18): 
      element
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (19-21): 
      is
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-23): 
      a
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-27): 
      set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      ,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-31): 
      it
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-37): 
      turns
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-42): 
      this
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (42-43): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (43-46): 
      Set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (46-47): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (47-49): 
      (.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (49-50): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (50-71): 
       into a list of Int,
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 681
   Float or Prop.

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-18): 
         Float or Prop.
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 682


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [115,61] BeginEndRule "meta.function.ts", entered @-1
      * [38,62] BeginEndRule "meta.var-single-variable.expr.ts", entered @-1
      * [36,63] BeginEndRule "meta.var.expr.ts", entered @-1
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 683
   WARNING: this function reverses the order of the elements of the set;

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-17): 
         WARNING: this 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (17-25): 
      function
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * storage.type.function.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (26-34): 
      reverses
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
      * entity.name.function.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
      * meta.function.overload.ts
    => TOKEN (35-71): 
      the order of the elements of the set
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.function.ts
    => TOKEN (71-73): 
      ;
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 684
   we could use fold_right in order to keep the original order, but

  LINE CONTAINS 3 TOKENS:
    => TOKEN (0-27): 
         we could use fold_right 
      * source.ts
    => TOKEN (27-29): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (29-68): 
       order to keep the original order, but
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 685
   it would mean that it is not tail recursion anymore (= uses much more heap)

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-25): 
         it would mean that it 
      * source.ts
    => TOKEN (25-27): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (27-55): 
       not tail recursion anymore 
      * source.ts
    => TOKEN (55-56): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (56-57): 
      =
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (57-77): 
       uses much more heap
      * source.ts
    => TOKEN (77-78): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 686


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,3] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 687
   If [!check_only] is true, then the lists *)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-6): 
         If 
      * source.ts
    => TOKEN (6-7): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (7-8): 
      !
      * source.ts
      * meta.array.literal.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (8-18): 
      check_only
      * source.ts
      * meta.array.literal.ts
    => TOKEN (18-19): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (19-20): 
       
      * source.ts
    => TOKEN (20-22): 
      is
      * source.ts
      * keyword.others.ts
    => TOKEN (22-23): 
       
      * source.ts
    => TOKEN (23-27): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (27-44): 
      , then the lists 
      * source.ts
    => TOKEN (44-45): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (45-46): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 688
and set_to_ast_list (env:env) (ast:Ast.t) :Ast.t list =

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-20): 
      and set_to_ast_list 
      * source.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (21-28): 
      env:env
      * source.ts
    => TOKEN (28-29): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (29-30): 
       
      * source.ts
    => TOKEN (30-31): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (31-40): 
      ast:Ast.t
      * source.ts
    => TOKEN (40-41): 
      )
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (41-54): 
       :Ast.t list 
      * source.ts
    => TOKEN (54-55): 
      =
      * source.ts
      * keyword.operator.comparison.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 689
  let lst = match ast_without_loc (eval_ast env ast) with

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.var.expr.ts
    => TOKEN (2-5): 
      let
      * source.ts
      * meta.var.expr.ts
      * storage.type.ts
    => TOKEN (5-6): 
       
      * source.ts
      * meta.var.expr.ts
    => TOKEN (6-9): 
      lst
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * variable.ts
    => TOKEN (9-11): 
       =
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (11-34): 
       match ast_without_loc 
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (34-35): 
      (
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (35-51): 
      eval_ast env ast
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (51-52): 
      )
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * meta.brace.paren.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
    => TOKEN (53-57): 
      with
      * source.ts
      * meta.var.expr.ts
      * meta.var-single-variable.expr.ts
      * keyword.control.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 690
  | Set s -> AstSet.elements s

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-10): 
       Set s 
      * source.ts
    => TOKEN (10-11): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (12-31): 
       AstSet.elements s
      * source.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 691
  | ast' -> raise_with_loc ast (

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (3-7): 
       ast
      * source.ts
    => TOKEN (7-8): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (8-31): 
       -> raise_with_loc ast 
      * source.ts
      * string.single.ts
    => TOKEN (31-32): 
      (
      * source.ts
      * string.single.ts

  LINE END RULE STACK CONTAINS 1 RULES:
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 692
      "after 'in', only sets are allowed, but got '"^(string_of_ast_type ast')^"':\n"^

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (7-51): 
      after 'in', only sets are allowed, but got '
      * source.ts
      * string.double.ts
    => TOKEN (51-52): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (52-53): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (53-54): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (54-76): 
      string_of_ast_type ast
      * source.ts
    => TOKEN (76-77): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (77-80): 
      )^"
      * source.ts
      * string.single.ts
    => TOKEN (80-81): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (81-84): 
      :\n
      * source.ts
    => TOKEN (84-85): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (85-86): 
      ^
      * source.ts
      * string.double.ts

  LINE END RULE STACK CONTAINS 2 RULES:
      * [33,69] BeginEndRule "null", entered @53
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 693
      "    "^(string_of_ast ast')^"\n"^

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (7-11): 
          
      * source.ts
      * string.double.ts
    => TOKEN (11-12): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (12-13): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-31): 
      string_of_ast ast
      * source.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (32-35): 
      )^"
      * source.ts
      * string.single.ts
    => TOKEN (35-37): 
      \n
      * source.ts
      * string.single.ts
      * constant.character.escape
    => TOKEN (37-38): 
      "
      * source.ts
      * string.single.ts
    => TOKEN (38-39): 
      ^
      * source.ts
      * string.single.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,70] BeginEndRule "null", entered @13
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 694
      "This element has been expanded to\n"^

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (7-40): 
      This element has been expanded to
      * source.ts
      * string.double.ts
    => TOKEN (40-42): 
      \n
      * source.ts
      * string.double.ts
      * constant.character.escape
    => TOKEN (42-43): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (43-44): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts

  LINE END RULE STACK CONTAINS 3 RULES:
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 695
      "    "^(string_of_ast ast')^"\n")

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-6): 
            
      * source.ts
    => TOKEN (6-7): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (7-11): 
          
      * source.ts
      * string.double.ts
    => TOKEN (11-12): 
      "
      * source.ts
      * string.double.ts
    => TOKEN (12-13): 
      ^
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (14-31): 
      string_of_ast ast
      * source.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (32-35): 
      )^"
      * source.ts
      * string.single.ts
    => TOKEN (35-37): 
      \n
      * source.ts
      * string.single.ts
      * constant.character.escape
    => TOKEN (37-38): 
      "
      * source.ts
      * string.single.ts
    => TOKEN (38-39): 
      )
      * source.ts
      * string.single.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @13
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 696
  in match !check_only, lst with (* useful when you only want to check types *)

  LINE CONTAINS 12 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-4): 
      in
      * source.ts
      * keyword.others.ts
    => TOKEN (4-11): 
       match 
      * source.ts
    => TOKEN (11-12): 
      !
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (12-28): 
      check_only, lst 
      * source.ts
    => TOKEN (28-32): 
      with
      * source.ts
      * keyword.control.ts
    => TOKEN (32-33): 
       
      * source.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (34-35): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (35-77): 
       useful when you only want to check types 
      * source.ts
    => TOKEN (77-78): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (78-79): 
      )
      * source.ts
      * meta.brace.paren.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 697
          | false,      _      -> lst

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-17): 
      false
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (17-31): 
      ,      _      
      * source.ts
    => TOKEN (31-32): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (33-38): 
       lst
      * source.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 698
          | true,       []     -> []

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-16): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (16-24): 
      ,       
      * source.ts
    => TOKEN (24-25): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (25-26): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (26-31): 
           
      * source.ts
    => TOKEN (31-32): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (33-34): 
       
      * source.ts
    => TOKEN (34-35): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (35-36): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 699
          | true,        x::xs -> [x]

  LINE CONTAINS 11 TOKENS:
    => TOKEN (0-10): 
                
      * source.ts
    => TOKEN (10-11): 
      |
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (11-12): 
       
      * source.ts
    => TOKEN (12-16): 
      true
      * source.ts
      * constant.language.boolean.ts
    => TOKEN (16-31): 
      ,        x::xs 
      * source.ts
    => TOKEN (31-32): 
      -
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (32-33): 
      >
      * source.ts
      * keyword.operator.comparison.ts
    => TOKEN (33-34): 
       
      * source.ts
    => TOKEN (34-35): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (35-36): 
      x
      * source.ts
      * meta.array.literal.ts
    => TOKEN (36-37): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 700


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts

  LINE END RULE STACK CONTAINS 4 RULES:
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 701
  (* [ast_to_bool] evaluates the 'when' condition when returns 'true' or 'false'

  LINE CONTAINS 19 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
    => TOKEN (2-3): 
      (
      * source.ts
      * meta.brace.paren.ts
    => TOKEN (3-4): 
      *
      * source.ts
      * keyword.operator.arithmetic.ts
    => TOKEN (4-5): 
       
      * source.ts
    => TOKEN (5-6): 
      [
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (6-17): 
      ast_to_bool
      * source.ts
      * meta.array.literal.ts
    => TOKEN (17-18): 
      ]
      * source.ts
      * meta.array.literal.ts
      * meta.brace.square.ts
    => TOKEN (18-33): 
       evaluates the 
      * source.ts
    => TOKEN (33-34): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (34-38): 
      when
      * source.ts
      * string.single.ts
    => TOKEN (38-39): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (39-63): 
       condition when returns 
      * source.ts
    => TOKEN (63-64): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (64-68): 
      true
      * source.ts
      * string.single.ts
    => TOKEN (68-69): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (69-73): 
       or 
      * source.ts
    => TOKEN (73-74): 
      '
      * source.ts
      * string.single.ts
    => TOKEN (74-79): 
      false
      * source.ts
      * string.single.ts
    => TOKEN (79-80): 
      '
      * source.ts
      * string.single.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [33,72] BeginEndRule "null", entered @0
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 702
     depending on the result.

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-30): 
           depending on the result.
      * source.ts

  LINE END RULE STACK CONTAINS 5 RULES:
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 703
     This function is used in Bigand and Bigor statements. *)

  LINE CONTAINS 6 TOKENS:
    => TOKEN (0-10): 
           This 
      * source.ts
    => TOKEN (10-18): 
      function
      * source.ts
      * meta.function.ts
      * storage.type.function.ts
    => TOKEN (18-19): 
       
      * source.ts
      * meta.function.ts
    => TOKEN (19-21): 
      is
      * source.ts
      * meta.function.ts
      * entity.name.function.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.function.ts
    => TOKEN (22-62): 
      used in Bigand and Bigor statements. *)
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @0
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 704
  and ast_to_bool env (ast:Ast.t) : bool =

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-22): 
        and ast_to_bool env 
      * source.ts
      * meta.function.ts
    => TOKEN (22-23): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (23-26): 
      ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
      :
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
    => TOKEN (27-32): 
      Ast.t
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.type.annotation.ts
      * meta.type.name.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-35): 
       :
      * source.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.function.ts
      * meta.return.type.ts
    => TOKEN (36-40): 
      bool
      * source.ts
      * meta.function.ts
      * meta.return.type.ts
      * meta.type.name.ts
    => TOKEN (40-42): 
       =
      * source.ts
      * meta.function.ts
      * meta.return.type.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 705
    match eval_ast env ast with

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-32): 
          match eval_ast env ast with
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 706
    | Bool b -> b

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-18): 
          | Bool b -> b
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 707
    | ast' -> raise_with_loc ast (

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-33): 
          | ast' -> raise_with_loc ast 
      * source.ts
      * meta.function.ts
    => TOKEN (33-34): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,74] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 708
      "'when' expects a 'bool' but got '"^(string_of_ast_type ast')^"':\n"^

  LINE CONTAINS 23 TOKENS:
    => TOKEN (0-8): 
            "'
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (8-12): 
      when
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-21): 
      expects
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-23): 
      a
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-25): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (25-29): 
      bool
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (30-31): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (31-34): 
      but
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-38): 
      got
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-43): 
      '"^(
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (43-61): 
      string_of_ast_type
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (62-65): 
      ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (65-66): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (66-67): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (67-76): 
      ^"':\n"^
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 709
      "    "^(string_of_ast ast')^"\n"^

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-13): 
            "    "^
      * source.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-27): 
      string_of_ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-40): 
      ^"\n"^
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 710
      "This element has been expanded to\n"^

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-45): 
            "This element has been expanded to\n"^
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 711
      "    "^(string_of_ast ast')^"\n")

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-13): 
            "    "^
      * source.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-27): 
      string_of_ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
      '
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-33): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (33-40): 
      ^"\n")
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 712
  (* To_int, To_float, Var, Int... all these cannot contain ToRemove because

  LINE CONTAINS 27 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.function.ts
    => TOKEN (2-3): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (3-4): 
      *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-11): 
      To_int
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (12-13): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (13-21): 
      To_float
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-26): 
      Var
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      Int
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-34): 
      ...
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * keyword.others.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-38): 
      all
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-44): 
      these
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-51): 
      cannot
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-59): 
      contain
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-68): 
      ToRemove
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-76): 
      because
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,75] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 713
     ToRemove can only be generated by exact, atleast, atmost, bigand and bigor.

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-13): 
      ToRemove
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-17): 
      can
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (18-22): 
      only
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-25): 
      be
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-35): 
      generated
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-38): 
      by
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-44): 
      exact
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-53): 
      atleast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (54-55): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (55-61): 
      atmost
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (61-62): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-63): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (63-69): 
      bigand
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (69-70): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (70-73): 
      and
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (73-74): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (74-79): 
      bigor
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (79-81): 
      .
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,75] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 714
     I only need to match the items that can potentially be produced by the

  LINE CONTAINS 28 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-6): 
      I
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (6-7): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (7-11): 
      only
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-16): 
      need
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-19): 
      to
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (20-25): 
      match
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (26-29): 
      the
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (29-30): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (30-35): 
      items
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-40): 
      that
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-44): 
      can
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-56): 
      potentially
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-59): 
      be
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-60): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (60-68): 
      produced
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (68-69): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (69-71): 
      by
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-75): 
      the
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,75] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 715
     above mentionned. And because "produced" means that everything has already

  LINE CONTAINS 23 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-10): 
      above
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (10-11): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (11-21): 
      mentionned
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
      .
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (22-23): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (23-26): 
      And
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (26-27): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (27-34): 
      because
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (34-35): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (35-36): 
      "
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (36-44): 
      produced
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      "
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (45-46): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (46-51): 
      means
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (51-52): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (52-56): 
      that
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-67): 
      everything
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (67-68): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (68-71): 
      has
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (71-72): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (72-79): 
      already
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,75] BeginEndRule "meta.function.type.parameter.ts", entered @-1
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 716
     been evaluated, all If, Var... have already disapeared. *)

  LINE CONTAINS 21 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-9): 
      been
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (9-10): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (10-19): 
      evaluated
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (19-20): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-24): 
      all
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (24-25): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (25-27): 
      If
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (28-29): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (29-32): 
      Var
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-35): 
      ...
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * keyword.others.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-40): 
      have
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-48): 
      already
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (48-49): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (49-59): 
      disapeared
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (59-62): 
      . *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (62-63): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 717
  and has_top_or_bot = function

  LINE CONTAINS 2 TOKENS:
    => TOKEN (0-23): 
        and has_top_or_bot = 
      * source.ts
      * meta.function.ts
    => TOKEN (23-31): 
      function
      * source.ts
      * meta.function.ts
      * meta.function.overload.ts
      * storage.type.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 718
    | Top | Bottom -> true

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-27): 
          | Top | Bottom -> true
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 719
    | Not x                  -> has_top_or_bot x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-49): 
          | Not x                  -> has_top_or_bot x
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 720
    | And     (x,y)          -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
          | And     
      * source.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-69): 
                -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 721
    | Or      (x,y)          -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
          | Or      
      * source.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-69): 
                -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 722
    | Xor     (x,y)          -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
          | Xor     
      * source.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-69): 
                -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 723
    | Implies (x,y)          -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
          | Implies 
      * source.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-69): 
                -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 724
    | Equiv   (x,y)          -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-14): 
          | Equiv   
      * source.ts
      * meta.function.ts
    => TOKEN (14-15): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-16): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (17-18): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (18-19): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (19-69): 
                -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 725
     (* the following items are just here because of SMT that

  LINE CONTAINS 23 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
    => TOKEN (5-6): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (6-7): 
      *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      the
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-21): 
      following
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (21-22): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (22-27): 
      items
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (28-31): 
      are
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (31-32): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (32-36): 
      just
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-41): 
      here
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (41-42): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (42-49): 
      because
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-52): 
      of
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (52-53): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (53-56): 
      SMT
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-61): 
      that
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,76] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 726
        allows ==, <, >, +, -, *... in formulas. *)

  LINE CONTAINS 13 TOKENS:
    => TOKEN (0-8): 
              
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-14): 
      allows
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-16): 
      =
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (16-17): 
      =
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * keyword.operator.comparison.ts
    => TOKEN (17-32): 
      , <, >, +, -, *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (32-35): 
      ...
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * keyword.others.ts
    => TOKEN (35-36): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (36-38): 
      in
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (38-39): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (39-47): 
      formulas
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (47-50): 
      . *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (50-51): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 727
    | Neg x                  -> has_top_or_bot x

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-49): 
          | Neg x                  -> has_top_or_bot x
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 728
    | Add (x,y)              -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
          | Add 
      * source.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-69): 
                    -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 729
    | Sub (x,y)              -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
          | Sub 
      * source.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-69): 
                    -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 730
    | Mul (x,y)              -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
          | Mul 
      * source.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-69): 
                    -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 731
    | Div (x,y)              -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-10): 
          | Div 
      * source.ts
      * meta.function.ts
    => TOKEN (10-11): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (11-12): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (12-13): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (13-14): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (15-69): 
                    -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 732
    | Equal            (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Equal            
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 733
    | Not_equal        (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Not_equal        
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 734
    | Lesser_than      (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Lesser_than      
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 735
    | Lesser_or_equal  (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Lesser_or_equal  
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 736
    | Greater_than     (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Greater_than     
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 737
    | Greater_or_equal (x,y) -> has_top_or_bot x || has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-23): 
          | Greater_or_equal 
      * source.ts
      * meta.function.ts
    => TOKEN (23-24): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (24-25): 
      x
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (25-26): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (26-27): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (27-28): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (28-69): 
       -> has_top_or_bot x || has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 738
    | Exists (_,y)           -> has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-13): 
          | Exists 
      * source.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-15): 
      _
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-49): 
                 -> has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 739
    | Forall (_,y)           -> has_top_or_bot y

  LINE CONTAINS 7 TOKENS:
    => TOKEN (0-13): 
          | Forall 
      * source.ts
      * meta.function.ts
    => TOKEN (13-14): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (14-15): 
      _
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (15-16): 
      ,
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (16-17): 
      y
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-18): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (18-49): 
                 -> has_top_or_bot y
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 740
    | _ -> false

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-17): 
          | _ -> false
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 741
  (* Simplify an AST by removing Bot and Top that can be absorbed

  LINE CONTAINS 27 TOKENS:
    => TOKEN (0-2): 
        
      * source.ts
      * meta.function.ts
    => TOKEN (2-3): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (3-4): 
      *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (4-5): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-13): 
      Simplify
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (13-14): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (14-16): 
      an
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (16-17): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (17-20): 
      AST
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (20-21): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (21-23): 
      by
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (23-24): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (24-32): 
      removing
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (32-33): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (33-36): 
      Bot
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (36-37): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (37-40): 
      and
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-44): 
      Top
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (45-49): 
      that
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (49-50): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (50-53): 
      can
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (53-54): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (54-56): 
      be
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (56-57): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (57-65): 
      absorbed
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts

  LINE END RULE STACK CONTAINS 7 RULES:
      * [78,77] BeginEndRule "meta.function.type.parameter.ts", entered @0
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 742
     by And or Or. *)

  LINE CONTAINS 10 TOKENS:
    => TOKEN (0-5): 
           
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (5-7): 
      by
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (7-8): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (8-11): 
      And
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (11-12): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (12-14): 
      or
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (14-15): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (15-17): 
      Or
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (17-20): 
      . *
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (20-21): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 743
  and rm_top_bot ast =

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-23): 
        and rm_top_bot ast =
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 744
    if ast != Top && ast != Bottom && has_top_or_bot ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-57): 
          if ast != Top && ast != Bottom && has_top_or_bot ast
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 745
    then rm_top_bot (eval_ast_formula [] ast)

  LINE CONTAINS 8 TOKENS:
    => TOKEN (0-20): 
          then rm_top_bot 
      * source.ts
      * meta.function.ts
    => TOKEN (20-21): 
      (
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts
    => TOKEN (21-37): 
      eval_ast_formula
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (37-38): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (38-40): 
      []
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
    => TOKEN (40-41): 
       
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
    => TOKEN (41-44): 
      ast
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * parameter.name.ts
      * variable.parameter.ts
    => TOKEN (44-45): 
      )
      * source.ts
      * meta.function.ts
      * meta.function.type.parameter.ts
      * meta.brace.round.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 746
    else ast

  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-13): 
          else ast
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1


===========================================
TOKENIZING LINE 747


  LINE CONTAINS 1 TOKENS:
    => TOKEN (0-1): 
      
      * source.ts
      * meta.function.ts

  LINE END RULE STACK CONTAINS 6 RULES:
      * [115,73] BeginEndRule "meta.function.ts", entered @-1
      * [33,72] BeginEndRule "null", entered @-1
      * [33,71] BeginEndRule "null", entered @-1
      * [33,70] BeginEndRule "null", entered @-1
      * [33,69] BeginEndRule "null", entered @-1
      * [1,1] IncludeOnlyRule "source.ts", entered @-1
